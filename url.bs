<pre class="metadata">
Title: URL Standard
Group: WHATWG
H1: URL
Shortname: url
Status: LS
No Editor: true
Abstract: The URL Standard defines URLs, domains, IP addresses, the <code title>application/x-www-form-urlencoded</code> format, and their API.
Logo: https://resources.whatwg.org/logo-url.svg
!Participate: <a href=https://github.com/whatwg/url>GitHub whatwg/url</a> (<a href=https://github.com/whatwg/url/issues/new>new issue</a>, <a href="https://github.com/whatwg/url/issues">open issues</a>, <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WHATWG&amp;component=URL&amp;resolution=---">legacy open bugs</a>)
!Participate: <a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
!Commits: <a href="https://github.com/whatwg/url/commits">https://github.com/whatwg/url/commits</a>
!Commits: <a href="https://twitter.com/urlstandard">@urlstandard</a>
Indent: 2
</pre>

<script src=https://resources.whatwg.org/file-issue.js async></script>

<h2 id=goals class=no-num>Goals</h2>

<p>The URL standard takes the following approach towards making URLs fully interoperable:

<ul>
 <li><p>Align RFC 3986 and RFC 3987 with contemporary implementations and
 obsolete them in the process. (E.g. spaces, other "illegal" code points,
 query encoding, equality, canonicalization, are all concepts not entirely
 shared, or defined.) URL parsing needs to become as solid as HTML parsing.
 [[RFC3986]]
 [[RFC3987]]

 <li><p>Standardize on the term URL. URI and IRI are just confusing. In
 practice a single algorithm is used for both so keeping them distinct is
 not helping anyone. URL also easily wins the
 <a href="http://www.googlefight.com/index.php?word1=url&amp;word2=uri">search result popularity contest</a>.

 <li><p>Supplanting <a href="https://tools.ietf.org/html/rfc6454#section-4">Origin of a URI [sic]</a>.
 [[RFC6454]]

 <li><p>Define URL's existing JavaScript API in full detail and add
 enhancements to make it easier to work with. Add a new <code><a interface>URL</a></code>
 object as well for URL manipulation without usage of HTML elements. (Useful
 for JavaScript worker environments.)
</ul>

<p class=note>As the editors learn more about the subject matter the goals
might increase in scope somewhat.



<h2 id=terminology>Terminology</h2>

<p>Some terms used in this specification are defined in the
DOM, Encoding, IDNA, and Web IDL Standards.
[[!DOM]]
[[!ENCODING]]
[[!IDNA]]
[[!WEBIDL]]

<p>The <dfn>ASCII digits</dfn> are code points in the range U+0030 to U+0039.
<!-- XXX ref Encoding? -->

<p>The <dfn>ASCII hex digits</dfn> are <a>ASCII digits</a> or are
code points in the range U+0041 to U+0046 or in the range U+0061 to U+0066.

<p>The <dfn>ASCII alpha</dfn> are code points in the range U+0041 to U+005A
or in the range U+0061 to U+007A.

<p>The <dfn>ASCII alphanumeric</dfn> are <a>ASCII digits</a> or
<a>ASCII alpha</a>.


<h3 id=parsers>Parsers</h3>

<p>The <dfn>EOF code point</dfn> is a conceptual code point that signifies the end of a
string or code point stream.

<p>A <dfn>parse error</dfn> indicates a non-fatal mismatch between input and requirements.
User agents are encouraged to expose <a lt="parse error">parse errors</a>
somehow.

<p>Within a parser algorithm that uses a <var>pointer</var> variable, <dfn>c</dfn>
references the code point the <var>pointer</var> variable points to.

<p>Within a string-based parser algorithm that uses a <var>pointer</var> variable,
<dfn>remaining</dfn> references the substring after <var>pointer</var> in the string
being processed.

<p class=example>If "<code>mailto:username@example</code>" is a string being
processed and <var>pointer</var> points to "<code>@</code>",
<a>c</a> is "<code>@</code>" and <a>remaining</a> is
"<code>example</code>".



<h2 id=percent-encoded-bytes>Percent-encoded bytes</h2>

<p>A <dfn>percent-encoded byte</dfn> is "<code>%</code>", followed by
two <a>ASCII hex digits</a>. Sequences of
<a lt="percent-encoded byte">percent-encoded bytes</a>, after
conversion to bytes, should not cause a
<a>utf-8 decoder</a> to run into any
<a lt=error>errors</a>.

<p>To <dfn>percent encode</dfn> a <var>byte</var> into a
<a>percent-encoded byte</a>, return a string consisting of
"<code>%</code>", followed by a double-digit, uppercase, hexadecimal
representation of <var>byte</var>.

<p>To <dfn>percent decode</dfn> a byte sequence <var>input</var>, run these steps:

<p class=warning>Using anything but a <a>utf-8 decoder</a>
when the <var>input</var> contains bytes outside the range 0x00 to 0x7F might be
insecure and is not recommended.

<ol>
 <li><p>Let <var>output</var> be an empty byte sequence.

 <li>
  <p>For each byte <var>byte</var> in <var>input</var>, run these steps:

  <ol>
   <li><p>If <var>byte</var> is not `<code>%</code>`, append
   <var>byte</var> to <var>output</var>.

   <li><p>Otherwise, if <var>byte</var> is `<code>%</code>` and the next two
   bytes after <var>byte</var> in <var>input</var> are not in the ranges
   0x30 to 0x39, 0x41 to 0x46, and 0x61 to 0x66, append <var>byte</var> to
   <var>output</var>.

   <li>
    <p>Otherwise, run these substeps:

    <ol>
     <li><p>Let <var>bytePoint</var> be the two bytes after <var>byte</var> in
     <var>input</var>,
     <a lt="utf-8 decode without BOM">decoded</a>, and
     then interpreted as hexadecimal number.
     <!-- We should have a definition for this that is saner. -->

     <li><p>Append a byte whose value is <var>bytePoint</var> to
     <var>output</var>.

     <li><p>Skip the next two bytes in <var>input</var>.
    </ol>
  </ol>

 <li><p>Return <var>output</var>.
</ol>

<!-- the escape sets are minimal as escaping can lead to problems; we might
     be able to escape more here but only if implementors are willing and
     there's an upside

     note that query and application/x-www-form-urlencoded use their own
     local sets -->
<p>The <dfn>simple encode set</dfn> are all code points less than
U+0020 (i.e. excluding U+0020) and all code points greater than U+007E.

<p>The <dfn>default encode set</dfn> is the
<a>simple encode set</a> and code points U+0020,
'<code>"</code>', <!-- 0x22 -->
"<code>#</code>", <!-- 0x23 -->
"<code>&lt;</code>", <!-- 0x3C -->
"<code>&gt;</code>", <!-- 0x3E -->
"<code>?</code>", <!-- 0x3F -->
and
"<code>`</code>". <!-- 0x60 -->

<p>The <dfn>password encode set</dfn> is the
<a>default encode set</a> and code points
"<code>/</code>", <!-- 0x2F -->
"<code>@</code>", <!-- 0x40 -->
and
"<code>\</code>". <!-- 0x5C -->

<p>The <dfn>username encode set</dfn> is the
<a>password encode set</a> and code point
"<code>:</code>". <!-- 0x3A -->

<p>To <dfn>utf-8 percent encode</dfn> a <var>code point</var>, using
an <var>encode set</var>, run these steps:

<ol>
 <li><p>If <var>code point</var> is not in
 <var>encode set</var>, return <var>code point</var>.

 <li><p>Let <var>bytes</var> be the result of running
 <a>utf-8 encode</a> on
 <var>code point</var>.

 <li><p><a>Percent encode</a> each byte in <var>bytes</var>, and
 then return them concatenated, in the same order.
</ol>



<h2 id="hosts-(domains-and-ip-addresses)">Hosts (domains and IP addresses)</h2>

<!-- Punycode:
     https://tools.ietf.org/html/rfc3492
     https://mothereff.in/punycode -->

<p>A <dfn id=concept-host lt='host'>host</dfn> is a network address in the form of a
<a>domain</a> or an
<a lt='IPv6'>IPv6 address</a>.

<p>A <dfn id=concept-domain lt='domain'>domain</dfn> identifies a realm within a network.

<p>An <dfn id=concept-ipv6 lt='IPv6'>IPv6 address</dfn> is a 128-bit identifier and
for the purposes of this specification represented as an ordered list of
eight <dfn id=concept-ipv6-piece lt='IPv6 piece'>16-bit pieces</dfn>.
[[RFC4291]]


<h3 id=idna>IDNA</h3>

<p>The <dfn id=concept-domain-to-ascii lt='domain to ASCII'>domain to ASCII</dfn> given a
<a>domain</a> <var>domain</var>, runs these steps:

<ol>
 <li><p>Let <var>result</var> be the result of running
 <a lt=ToASCII>Unicode ToASCII</a> with
 <i>domain_name</i> set to <var>domain</var>,
 <i>UseSTD3ASCIIRules</i> set to false, <i>processing_option</i> set to
 <i>Transitional_Processing</i>, and <i>VerifyDnsLength</i> set to false.

 <li><p>If <var>result</var> is a failure value, return failure.

 <li><p>Return <var>result</var>.
</ol>

<p>The <dfn id=concept-domain-to-unicode lt='domain to Unicode'>domain to Unicode</dfn> given a
<a>domain</a> <var>domain</var>, runs these steps:

<ol>
 <li><p>Let <var>result</var> be the result of running
 <a lt=ToUnicode>Unicode ToUnicode</a> with
 <i>domain_name</i> set to <var>domain</var>,
 <i>UseSTD3ASCIIRules</i> set to false.

 <li>
  <p>Return <var>result</var>, ignoring any returned errors.

  <p class=note>User agents are encouraged to report errors through a developer console.
</ol>


<h3 id=host-writing>Host writing</h3>

<p>A <a>host</a> must be either a
<a>domain</a> or "<code>[</code>", followed
by an <a lt='IPv6'>IPv6 address</a>, followed by
"<code>]</code>".

<p>A <var>domain</var> is a <dfn>valid domain</dfn> if these steps return success:

<ol>
 <li><p>Let <var>result</var> be the result of running
 <a lt=ToASCII>Unicode ToASCII</a> with
 <i>domain_name</i> set to <var>domain</var>,
 <i>UseSTD3ASCIIRules</i> set to true, <i>processing_option</i> set to
 <i>Nontransitional_Processing</i>, and <i>VerifyDnsLength</i> set to true.

 <li><p>If <var>result</var> is a failure value, return failure.

 <li><p>Set <var>result</var> to the result of running
 <a lt=ToUnicode>Unicode ToUnicode</a> with
 <i>domain_name</i> set to <var>result</var>,
 <i>UseSTD3ASCIIRules</i> set to true.

 <li><p>If <var>result</var> contains any errors, return failure.

 <li><p>Return success.
</ol>

<p class=XXX>Ideally we define this in terms of a sequence of code points that make up a
<a>valid domain</a> rather than through a whack-a-mole:
<a href=https://www.w3.org/Bugs/Public/show_bug.cgi?id=25334>bug 25334</a>.

<p>A <a>domain</a> must be a string that is a
<a>valid domain</a>.

<p>An <a lt='IPv6'>IPv6 address</a> is defined in the
<a href="https://tools.ietf.org/html/rfc4291#section-2.2">"Text Representation of Addresses" chapter of IP Version 6 Addressing Architecture</a>.
[[!RFC4291]]
<!-- https://tools.ietf.org/html/rfc5952 updates that RFC, but it seems as
     far as what developers can do we should be liberal

     XXX should we define the format inline instead just like STD 66? -->


<h3 id=host-parsing>Host parsing</h3>

<p>The <dfn id=concept-host-parser lt='host parser'>host parser</dfn> takes a string
<var>input</var> and optionally a <var>Unicode flag</var>, and then runs
these steps:

<ol>
 <li><p>If <var>input</var> is the empty string, return failure.
 <!-- Otherwise parsing URLs would not be idempotent:

      http://@/example.org/ -> http:///example.org/ -> http://example.org/

      Could potentially move this check to the URL parser if deemed problematic. -->

 <li>
  <p>If <var>input</var> starts with "<code>[</code>", run these
  substeps:

  <ol>
   <li><p>If <var>input</var> does not end with
   "<code>]</code>", <a>parse error</a>, return failure.

   <li><p>Return the result of
   <a lt='IPv6 parser'>IPv6 parsing</a> <var>input</var>
   with its leading "<code>[</code>" and trailing
   "<code>]</code>" removed.
  </ol>

 <li><p>Let <var>domain</var> be the result of
 <a>utf-8 decode without BOM</a> on the
 <a lt="percent decode">percent decoding</a> of
 <a>utf-8 encode</a> on <var>input</var>.
 <!-- https://bugzilla.mozilla.org/show_bug.cgi?id=309671 -->

 <li><p>Let <var>asciiDomain</var> be the result of running
 <a>domain to ASCII</a> on <var>domain</var>.

 <li><p>If <var>asciiDomain</var> is failure, return failure.

 <li>
  <p>If <var>asciiDomain</var> contains one of
  U+0000,
  U+0009,
  U+000A,
  U+000D,
  U+0020,
  "<code>#</code>",<!-- 23 -->
  "<code>%</code>",<!-- 25 -->
  "<code>/</code>",<!-- 2F -->
  "<code>:</code>",<!-- 3A -->
  "<code>?</code>",<!-- 3F -->
  "<code>@</code>",<!-- 40 -->
  "<code>[</code>",<!-- 5B -->
  "<code>\</code>",<!-- 5C -->
  and
  "<code>]</code>",<!-- 5D -->
  return failure.

 <li><p>Return <var>asciiDomain</var> if the <var>Unicode flag</var> is unset,
 and the result of running <a>domain to Unicode</a>
 on <var>asciiDomain</var> otherwise.
</ol>

<p>The <dfn id=concept-ipv6-parser lt='IPv6 parser'>IPv6 parser</dfn> takes a string
<var>input</var> and then runs these steps:

<ol>
 <li><p>Let <var>address</var> be a new
 <a lt='IPv6'>IPv6 address</a> with its
 <a lt='IPv6 piece'>16-bit pieces</a> initialized to 0.

 <li><p>Let <var>piece pointer</var> be a pointer into
 <var>address</var>'s
 <a lt='IPv6 piece'>16-bit pieces</a>, initially zero
 (pointing to the first <a lt='IPv6 piece'>16-bit piece</a>),
 and let <var>piece</var> be the
 <a lt='IPv6 piece'>16-bit piece</a> it points to.

 <li><p>Let <var>compress pointer</var> be another pointer into
 <var>address</var>'s <a lt='IPv6 piece'>16-bit pieces</a>, initially
 null and pointing to nothing.

 <li><p>Let <var>pointer</var> be a pointer into
 <var>input</var>, initially zero (pointing to the first code point).

 <li>
  <p>If <a>c</a> is "<code>:</code>", run these substeps:

  <ol>
   <li><p>If <a>remaining</a> does not start with
   "<code>:</code>", <a>parse error</a>, return failure.

   <li><p>Increase <var>pointer</var> by two.

   <li><p>Increase <var>piece pointer</var> by one and then set
   <var>compress pointer</var> to <var>piece pointer</var>.
  </ol>

 <li>
  <p><dfn id=concept-ipv6-parser-main lt='IPv6 parser Main'>Main</dfn>:
  While <a>c</a> is not the <a>EOF code point</a>, run these
  substeps:

  <ol>
   <li><p>If <var>piece pointer</var> is eight,
   <a>parse error</a>, return failure.

   <li>
    <p>If <a>c</a> is "<code>:</code>", run these inner
    substeps:

    <ol>
     <li><p>If <var>compress pointer</var> is not null,
     <a>parse error</a>, return failure.

     <li>Increase <var>pointer</var> and <var>piece pointer</var> by one, set
     <var>compress pointer</var> to <var>piece pointer</var>,
     and then jump to <a lt='IPv6 parser Main'>Main</a>.
    </ol>

   <li><p>Let <var>value</var> and <var>length</var> be 0.

   <li><p>While <var>length</var> is less than 4 and
   <a>c</a> is an
   <a lt="ASCII hex digits">ASCII hex digit</a>, set
   <var>value</var> to
   <var>value</var> &times; 0x10 + <a>c</a> interpreted as hexadecimal number,
   and increase <var>pointer</var> and <var>length</var> by one.

   <li>
    <p>Based on <a>c</a>:

    <dl class=switch>
     <dt>"<code>.</code>"
     <dd>
      <p>If <var>length</var> is 0, <a>parse error</a>,
      return failure.
      <p>Decrease <var>pointer</var> by <var>length</var>.
      <p>Jump to <a lt='IPv6 parser IPv4'>IPv4</a>.

     <dt>"<code>:</code>"
     <dd>
      <p>Increase <var>pointer</var> by one.
      <p>If <a>c</a> is the <a>EOF code point</a>,
      <a>parse error</a>, return failure.

     <dt>Anything but the <a>EOF code point</a>
     <dd><p><a>Parse error</a>, return failure.
    </dl>

   <li><p>Set <var>piece</var> to <var>value</var>.

   <li><p>Increase <var>piece pointer</var> by one.
  </ol>

 <li><p>If <a>c</a> is the <a>EOF code point</a>, jump to
 <a lt='IPv6 parser Finale'>Finale</a>.

 <li><p><dfn id=concept-ipv6-parser-ipv4 lt='IPv6 parser IPv4'>IPv4</dfn>:
 If <var>piece pointer</var> is greater than six,
 <a>parse error</a>, return failure.

 <li><p>Let <var>dots seen</var> be 0.

 <li>
  <p>While <a>c</a> is not the <a>EOF code point</a>, run
  these substeps:

  <ol>
   <li><p>Let <var>value</var> be null.

   <li><p>If <a>c</a> is not an <a lt="ASCII digits">ASCII digit</a>,
   <a>parse error</a>, return failure. <!-- prevent the empty string -->

   <li>
    <p>While <a>c</a> is an
    <a lt="ASCII digits">ASCII digit</a>, run these subsubsteps:

    <ol>
     <li><p>Let <var>number</var> be <a>c</a> interpreted as decimal number.

     <li>
      <p>If <var>value</var> is null, set <var>value</var> to <var>number</var>.

      <p>Otherwise, if <var>value</var> is 0, <a>parse error</a>, return failure.

      <p>Otherwise, set <var>value</var> to <var>value</var> &times; 10 + <var>number</var>.

     <li><p>Increase <var>pointer</var> by one.

     <li><p>If <var>value</var> is greater than 255, <a>parse error</a>,
     return failure.
    </ol>

   <li><p>If <var>dots seen</var> is less than 3 and
   <a>c</a> is not a "<code>.</code>",
   <a>parse error</a>, return failure.

   <li><p>Set <var>piece</var> to
   <var>piece</var> &times; 0x100 + <var>value</var>.

   <li><p>If <var>dots seen</var> is 1 or 3, increase
   <var>piece pointer</var> by one.

   <li><p>Increase <var>pointer</var> by one.

   <li><p>If <var>dots seen</var> is 3 and <a>c</a> is not
   the <a>EOF code point</a>,
   <a>parse error</a>, return failure.

   <li><p>Increase <var>dots seen</var> by one.
  </ol>

 <li>
  <p><dfn id=concept-ipv6-parser-finale lt='IPv6 parser Finale'>Finale</dfn>:
  If <var>compress pointer</var> is not null, run these substeps:

  <ol>
   <li><p>Let <var>swaps</var> be
   <var>piece pointer</var> &minus; <var>compress pointer</var>.

   <li><p>Set <var>piece pointer</var> to seven.

   <li><p>While <var>piece pointer</var> is not zero and <var>swaps</var> is
   greater than zero, swap <var>piece</var> with the
   <a lt='IPv6 piece'>piece</a> at pointer
   <var>compress pointer</var> + <var>swaps</var> &minus; 1, and then
   decrease both <var>piece pointer</var> and <var>swaps</var> by one.
  </ol>

 <li><p>Otherwise, if <var>compress pointer</var> is null and
 <var>piece pointer</var> is not eight, <a>parse error</a>,
 return failure.

 <li><p>Return <var>address</var>.
</ol>


<h3 id=host-serializing>Host serializing</h3>

<p>The <dfn id=concept-host-serializer lt='host serializer'>host serializer</dfn> takes null or a
<a>host</a> <var>host</var> and then runs
these steps:

<ol>
 <li><p>If <var>host</var> is null, return the empty string.

 <li><p>If <var>host</var> is an
 <a lt='IPv6'>IPv6 address</a>, return
 "<code>[</code>", followed by the result of running the
 <a>IPv6 serializer</a> on <var>host</var>,
 followed by "<code>]</code>".

 <li><p>Otherwise, <var>host</var> is a <a>domain</a>,
 return <var>host</var>.
</ol>

<p>The <dfn id=concept-ipv6-serializer lt='IPv6 serializer'>IPv6 serializer</dfn> takes an
<a lt='IPv6'>IPv6 address</a> <var>address</var> and
then runs these steps:

<ol>
 <li><p>Let <var>output</var> be the empty string.

 <li>
  <p>Let <var>compress pointer</var> be a pointer to the first
  <a lt='IPv6 piece'>16-bit piece</a> in the first longest
  sequences of <var>address</var>'s
  <a lt='IPv6 piece'>16-bit pieces</a> that are 0.

  <p class=example>In <code>0:f:0:0:f:f:0:0</code> it would point to
  the second 0.

 <li><p>If there is no sequence of <var>address</var>'s
 <a lt='IPv6 piece'>16-bit pieces</a> that are 0 longer than
 one, set <var>compress pointer</var> to null.

 <li>
  <p>For each <var>piece</var> in <var>address</var>'s
  <a lt='IPv6 piece'>pieces</a>, run these substeps:

  <ol>
   <li><p>If <var>compress pointer</var> points to
   <var>piece</var>, append "<code>::</code>" to
   <var>output</var> if <var>piece</var> is
   <var>address</var>'s first <a lt='IPv6 piece'>piece</a> and append
   "<code>:</code>" otherwise, and then run these substeps again with all
   subsequent <a lt='IPv6 piece'>pieces</a> in
   <var>address</var>'s <a lt='IPv6 piece'>pieces</a>
   that are 0 skipped or go the next step in the overall set of steps if
   that leaves no <a lt='IPv6 piece'>pieces</a>.

   <li><p>Append <var>piece</var>, represented as the shortest
   possible lowercase hexadecimal number, to <var>output</var>.

   <li><p>If <var>piece</var> is not
   <var>address</var>'s last <a lt='IPv6 piece'>piece</a>,
   append "<code>:</code>" to <var>output</var>.
  </ol>

 <li><p>Return <var>output</var>.
</ol>

<p class=note>This algorithm requires the recommendation from
A Recommendation for IPv6 Address Text Representation.
[[RFC5952]]

<!-- Safari/Gecko/Opera do not normalize IPv6. Chrome does. This algorithm
     follows Chrome because we normalize domains too. -->



<h2 id=urls>URLs</h2>

<!-- History behind URL as term:
     https://lists.w3.org/Archives/Public/uri/2012Oct/0080.html -->

<p>A <dfn id=concept-url lt='URL'>URL</dfn> is a universal identifier.

<p>A <a>URL</a> consists of components, namely a
<a lt='URL scheme'>scheme</a>,
<a lt='URL scheme data'>scheme data</a>,
<a lt='URL username'>username</a>,
<a lt='URL password'>password</a>,
<a lt='URL host'>host</a>,
<a lt='URL port'>port</a>,
<a lt='URL path'>path</a>,
<a lt='URL query'>query</a>, and
<a lt='URL fragment'>fragment</a>.

<p>A <a>URL</a>'s <dfn id=concept-url-scheme lt='URL scheme'>scheme</dfn> is
a string that identifies the type of <a>URL</a> and can be used to
dispatch a <a>URL</a> for further processing after
<a lt='URL parser'>parsing</a>. It is initially the empty string.

<p>A <a>URL</a>'s
<dfn id=concept-url-scheme-data lt='URL scheme data'>scheme data</dfn> is a string holding the contents of a
<a>URL</a>. It is initially the empty string.

<p class="note no-backref">A <a>URL</a>'s
<a lt='URL scheme data'>scheme data</a> will be its initial value if its
<a lt='URL scheme'>scheme</a> is a <a>relative scheme</a>, and
otherwise will be the only component without an initial value.

<p>A  <a>URL</a>'s <dfn id=concept-url-username lt='URL username'>username</dfn>
is a string identifying a user. It is initially the empty string.

<p>A  <a>URL</a>'s <dfn id=concept-url-password lt='URL password'>password</dfn>
is either null or a string identifying a user's credentials. It is initially null.

<p>A  <a>URL</a>'s <dfn id=concept-url-host lt='URL host'>host</dfn> is
either null or a <a>host</a>. It is initially null.

<p>A  <a>URL</a>'s <dfn id=concept-url-port lt='URL port'>port</dfn> is a
string that identifies a networking port. It is initially the empty string.

<p>A  <a>URL</a>'s <dfn id=concept-url-path lt='URL path'>path</dfn> is a
list of zero or more strings holding data, usually identifying a location in hierarchical
form. It is initially the empty list.

<p>A  <a>URL</a>'s <dfn id=concept-url-query lt='URL query'>query</dfn> is
either null or a string holding data. It is initially null.

<p>A <a>URL</a>'s <dfn id=concept-url-fragment lt='URL fragment'>fragment</dfn>
is either null or a string holding data that can be used for further processing on the
resource the <a>URL</a>'s other components identify.
It is initially null.

<p>A <a>URL</a> also has an associated <dfn>relative flag</dfn>.
It is initially unset.

<p class="note no-backref">The <a>relative flag</a> exists as checking if a
<a>URL</a>'s <a lt='URL scheme'>scheme</a> is a
<a>relative scheme</a> can give incorrect results due to the
<code><a attribute for=URLUtils>protocol</a></code> attribute.
<!-- XXX maybe disallow setting protocol to non-sensical values -->

<p>A <a>URL</a> also has an associated
<dfn id=concept-url-object lt='URL object'>object</dfn> that is either null or a
<code><a>Blob</a></code> object. It is initially null.
[[!FILEAPI]]

<p class="note">At this point this is used primarily to support "<code>blob</code>"
URLs, but others can be added going forward, hence "object".


<p>A <dfn>relative scheme</dfn> is a
<a lt='URL scheme'>scheme</a> listed in the first column of
the following table. A <dfn>default port</dfn> is a
<a>relative scheme</a>'s optional corresponding
<a lt='URL port'>port</a> and is listed in the second column
on the same row.

<table>
 <tr><th><a lt='URL scheme'>scheme</a>
     <th><a lt='URL port'>port</a>
 <tr><td>"<code>ftp</code>"<td>"<code>21</code>"
 <tr><td>"<code>file</code>"<td>
 <tr><td>"<code>gopher</code>"<td>"<code>70</code>"
 <tr><td>"<code>http</code>"<td>"<code>80</code>"
 <tr><td>"<code>https</code>"<td>"<code>443</code>"
 <tr><td>"<code>ws</code>"<td>"<code>80</code>"
 <tr><td>"<code>wss</code>"<td>"<code>443</code>"
</table>

<!-- The best reason I have for listing "gopher" is Google does it too:
     https://code.google.com/p/google-url/source/browse/trunk/src/url_canon_stdurl.cc#120

     It seems fine to remain compatible on that front, no need to support it
     elsewhere though. -->

<p>A <dfn>local scheme</dfn> is a <a lt="URL scheme">scheme</a> that is one of
"<code>about</code>", "<code>blob</code>", "<code>data</code>", and
"<code>filesystem</code>".

<p>A <a>URL</a> <dfn>is local</dfn> if its <a lt="URL scheme">scheme</a> is a
<a>local scheme</a>.

<p>A <a>URL</a>
<dfn lt="include credentials">includes credentials</dfn> if either its
<a lt='URL username'>username</a> is not the empty string or its
<a lt='URL password'>password</a> is non-null.
<!-- used by Fetch -->

<p>A <a>URL</a> can be designated as
<dfn id=concept-base-url lt='base URL'>base URL</dfn>.

<p class="note no-backref">A <a>base URL</a> is useful for
the <a>URL parser</a> when the input is potentially a
<a>relative URL</a>.


<h3 id=url-writing>URL writing</h3>

<!-- http://tantek.com/2011/238/b1/many-ways-slice-url-name-pieces -->

<p>A <a>URL</a> must be written as either a
<a>relative URL</a> or an
<a>absolute URL</a>, optionally followed by
"<code>#</code>" and a
<a lt='URL fragment'>fragment</a>.

<p>An <dfn id=concept-absolute-url lt='absolute URL'>absolute URL</dfn> must be a
<a lt='URL scheme'>scheme</a>, followed by
"<code>:</code>", followed by either a
<a>scheme-relative URL</a>, if
<a lt='URL scheme'>scheme</a> is a <a>relative scheme</a>, or
<a lt='URL scheme data'>scheme data</a> otherwise, optionally followed
by "<code>?</code>" and a <a lt='URL query'>query</a>.

<p>A <a lt='URL scheme'>scheme</a> must be one
<a>ASCII alpha</a>, followed by zero or more of
<a>ASCII alphanumeric</a>, "<code>+</code>",
"<code>-</code>", and "<code>.</code>". A
<a lt='URL scheme'>scheme</a> must be registered
<span class=XXX>...</span>.

<p>The syntax of <a lt='URL scheme data'>scheme data</a>
depends on the <a lt='URL scheme'>scheme</a> and is typically
defined alongside it. Standards must define
<a lt='URL scheme data'>scheme data</a> within the constraints of zero or
more <a>URL units</a>, excluding "<code>?</code>".

<p>A <dfn id=concept-relative-url lt='relative URL'>relative URL</dfn> must be either a
<a>scheme-relative URL</a>, an
<a>absolute-path-relative URL</a>,
or a <a>path-relative URL</a> that
does not start with a <a lt='URL scheme'>scheme</a> and
"<code>:</code>", optionally followed by a "<code>?</code>" and
a <a lt='URL query'>query</a>.

<p>At the point where a <a>relative URL</a> is
<a lt='URL parser'>parsed</a>, a
<a>base URL</a> must be in scope.

<p>A <dfn id=concept-scheme-relative-url lt='scheme-relative URL'>scheme-relative URL</dfn> must be
"<code>//</code>", optionally followed by
<a lt='URL Userinfo'>userinfo</a> and "<code>@</code>",
followed by a <a>host</a>, optionally followed
by "<code>:</code>" and a <a lt='URL port'>port</a>,
optionally followed by an
<a>absolute-path-relative URL</a>.

<p><dfn id=concept-url-userinfo lt='URL Userinfo'>Userinfo</dfn> must be a
<a lt='URL username'>username</a>, optionally followed by a
"<code>:</code>" and a
<a lt='URL password'>password</a>.

<p>A <a lt='URL username'>username</a> must be zero or more
<a>URL units</a>, excluding "<code>/</code>",
"<code>:</code>, "<code>?</code>", and "<code>@</code>".
<!-- password without ":" (sorted on ASCII position) -->

<p>A <a lt='URL password'>password</a> must be zero or more
<a>URL units</a>, excluding "<code>/</code>",
"<code>?</code>", and "<code>@</code>".

<p>A <a lt='URL port'>port</a> must be zero or more
<a>ASCII digits</a>.

<p>An
<dfn id=concept-absolute-path-relative-url lt='absolute-path-relative URL'>absolute-path-relative URL</dfn>
must be "<code>/</code>", followed by a
<a>path-relative URL</a> that does not
start with "<code>/</code>".

<p>A <dfn id=concept-path-relative-url lt='path-relative URL'>path-relative URL</dfn> must be zero or
more <a lt="path segment">path segments</a> separated from each
other by a "<code>/</code>".

<p>A <dfn>path segment</dfn> must be zero or more <a>URL units</a>,
excluding "<code>/</code>" and "<code>?</code>".

<p>A <a lt='URL query'>query</a> must be zero or more
<a>URL units</a>.

<p>A <a lt='URL fragment'>fragment</a> must be zero or more
<a>URL units</a>.

<p>The <dfn>URL code points</dfn> are <a>ASCII alphanumeric</a>,
"<code>!</code>",<!-- 0x21, sub-delims -->
"<code>$</code>",<!-- 0x24, sub-delims -->
"<code>&</code>",<!-- 0x26, sub-delims -->
"<code>'</code>",<!-- 0x27, sub-delims -->
"<code>(</code>",<!-- 0x28, sub-delims -->
"<code>)</code>",<!-- 0x29, sub-delims -->
"<code>*</code>",<!-- 0x2A, sub-delims -->
"<code>+</code>",<!-- 0x2B, sub-delims -->
"<code>,</code>",<!-- 0x2C, sub-delims -->
"<code>-</code>",<!-- 0x2D, iunreserved -->
"<code>.</code>",<!-- 0x2E, iunreserved -->
"<code>/</code>",<!-- 0x2F, iquery/ifragment -->
"<code>:</code>",<!-- 0x3A, ipchar -->
"<code>;</code>",<!-- 0x3B, sub-delims -->
"<code>=</code>",<!-- 0x3D, sub-delims -->
"<code>?</code>",<!-- 0x3F, iquery/ifragment -->
"<code>@</code>",<!-- 0x40, ipchar -->
"<code>_</code>",<!-- 0x5F, iunreserved -->
"<code>~</code>",<!-- 0x7E, iunreserved -->
and code points in the ranges
U+00A0 to U+D7FF,
U+E000 to <!--U+F8FF,
U+F900 to -->U+FDCF,
U+FDF0 to U+FFFD,<!-- changed relative to IRI from U+FFEF to U+FFFD to align with HTML-->
U+10000 to U+1FFFD,
U+20000 to U+2FFFD,
U+30000 to U+3FFFD,
U+40000 to U+4FFFD,
U+50000 to U+5FFFD,
U+60000 to U+6FFFD,
U+70000 to U+7FFFD,
U+80000 to U+8FFFD,
U+90000 to U+9FFFD,
U+A0000 to U+AFFFD,
U+B0000 to U+BFFFD,
U+C0000 to U+CFFFD,
U+D0000 to U+DFFFD,
U+E0000 to U+EFFFD,<!-- changed relative to IRI from E1000 to E0000 to align with HTML-->
U+F0000 to U+FFFFD,
U+100000 to U+10FFFD.

<p class=note>Code points higher than U+009F will be converted to
<a lt="percent-encoded byte">percent-encoded bytes</a> by the
<a>URL parser</a>, except for code points appearing in
<a lt="URL fragment">fragments</a>.

<p>The <dfn>URL units</dfn> are <a>URL code points</a> and
<a lt="percent-encoded byte">percent-encoded bytes</a>.


<h3 id=url-parsing>URL parsing</h3>

<p class=XXX>Add the ability to halt on the first conformance error.

<p>The <dfn id=concept-url-parser lt='URL parser'>URL parser</dfn> takes a string
<var>input</var>, optionally with a
<a>base URL</a> <var>base</var>, and
optionally with an <a>encoding</a>
<var>encoding override</var>, and then runs these steps:

<ol>
 <li><p>Let <var>url</var> be the result of running the
 <a>basic URL parser</a> on <var>input</var>
 with <var>base</var>, and <var>encoding override</var> as provided.

 <li><p>If <var>url</var> is failure, return failure.

 <li><p>If <var>url</var>'s <a lt='URL scheme'>scheme</a> is not
 "<code>blob</code>", return <var>url</var>.

 <li><p>If <var>url</var>'s <a lt='URL scheme data'>scheme data</a>
 is not in the <a>blob URL store</a>, return
 <var>url</var>. [[!FILEAPI]]

 <li><p>Set <var>url</var>'s <a lt='URL object'>object</a> to a
 <a>structured clone</a> of the entry in the
 <a>blob URL store</a> corresponding to
 <var>url</var>'s <a lt='URL scheme data'>scheme data</a>.
 [[!HTML]]

 <li><p>Return <var>url</var>.
</ol>

<hr>

<p>The <dfn id=concept-basic-url-parser lt='basic URL parser'>basic URL parser</dfn> takes a string
<var>input</var>, optionally with a
<a>base URL</a> <var>base</var>,
optionally with an <a>encoding</a>
<var>encoding override</var>, optionally with an
<a>URL</a> <var>url</var> and a state override
<var>state override</var>, and then runs these steps:

<div class="note no-backref">
 <p>The <var>encoding override</var> argument is a legacy concept only relevant for
 HTML. The <var>url</var> and <var>state override</var> arguments are only for
 use by methods of objects implementing the {{URLUtils}} interface.
 [[!HTML]]

 <p>When the <var>url</var> and <var>state override</var> arguments are not
 passed the <a>basic URL parser</a> returns either a
 <a>URL</a> or failure. If they are passed the
 algorithm simply modifies the passed <var>url</var> and can terminate without
 returning anything.
</div>

<ol>
 <li>
  <p>If <var>url</var> is not given:

  <ol>
   <li><p>Set <var>url</var> to a new <a>URL</a>.

   <li><p>Remove any leading and trailing
   <a>ASCII whitespace</a> from
   <var>input</var>.
  </ol>

 <li><p>Let <var>state</var> be <var>state override</var>
 if given, or <a>scheme start state</a> otherwise.

 <li><p>If <var>base</var> is not given, set it to null.

 <li><p>If <var>encoding override</var> is not given, set it to
 <a>utf-8</a>.

 <li><p>Let <var>buffer</var> be the empty string.

 <li><p>Let the <var>@ flag</var> and the <var>[] flag</var> be
 unset.

 <li><p>Let <var>pointer</var> be a pointer to first code point in
 <var>input</var>.

 <li>
  <p>Keep running the following state machine by switching on <var>state</var>. If
  after a run <var>pointer</var> points to the <a>EOF code point</a>, go to
  the next step. Otherwise, increase <var>pointer</var> by one and continue with the
  state machine.

  <dl class=switch>
   <dt><dfn>scheme start state</dfn>
   <dd>
    <ol>
     <li><p>If <a>c</a> is an <a>ASCII alpha</a>,
     append <a>c</a>, lowercased, to <var>buffer</var>, and
     set <var>state</var> to <a>scheme state</a>.

     <li><p>Otherwise, if <var>state override</var> is not given, set
     <var>state</var> to <a>no scheme state</a>, and decrease
     <var>pointer</var> by one.

     <li><p>Otherwise, <a>parse error</a>, terminate this algorithm.
    </ol>

   <dt><dfn>scheme state</dfn>
   <dd>
    <ol>
     <li><p>If <a>c</a> is an <a>ASCII alphanumeric</a>,
     "<code>+</code>", "<code>-</code>", or
     "<code>.</code>", append <a>c</a>, lowercased, to
     <var>buffer</var>.

     <li>
      <p>Otherwise, if <a>c</a> is "<code>:</code>", set
      <var>url</var>'s <a lt='URL scheme'>scheme</a> to
      <var>buffer</var>, <var>buffer</var> to the empty string,
      and then run these substeps:

      <ol>
       <li><p>If <var>state override</var> is given,
       terminate this algorithm.

       <li><p>If <var>url</var>'s
       <a lt='URL scheme'>scheme</a> is
       a <a>relative scheme</a>, set <var>url</var>'s
       <a>relative flag</a>.

       <li><p>If <var>url</var>'s
       <a lt='URL scheme'>scheme</a> is
       "<code>file</code>", set <var>state</var> to
       <a>relative state</a>.

       <li><p>Otherwise, if <var>url</var>'s
       <a>relative flag</a> is set, <var>base</var> is not null
       and <var>base</var>'s
       <a lt='URL scheme'>scheme</a> is equal to
       <var>url</var>'s <a lt='URL scheme'>scheme</a>,
       set <var>state</var> to
       <a>relative or authority state</a>.

       <li><p>Otherwise, if <var>url</var>'s
       <a>relative flag</a> is set, set <var>state</var> to
       <a>authority first slash state</a>.

       <li><p>Otherwise, set <var>state</var> to
       <a>scheme data state</a>.
      </ol>

     <li><p>Otherwise, if <var>state override</var> is not given, set
     <var>buffer</var> to the empty string, <var>state</var> to
     <a>no scheme state</a>, and start over (from the first code point
     in <var>input</var>).

     <li><p>Otherwise, if <a>c</a> is the
     <a>EOF code point</a>, terminate this algorithm.
     <!-- account for URL.protocol = "test" -->

     <li><p>Otherwise, <a>parse error</a>, terminate this algorithm.
    </ol>

   <dt><dfn>scheme data state</dfn>
   <dd>
    <ol>
     <li><p>If <a>c</a> is "<code>?</code>", set
     <var>url</var>'s <a lt='URL query'>query</a>
     to the empty string and <var>state</var> to
     <a>query state</a>.

     <li><p>Otherwise, if <a>c</a> is "<code>#</code>", set
     <var>url</var>'s <a lt='URL fragment'>fragment</a>
     to the empty string and <var>state</var> to
     <a>fragment state</a>.

     <li>
      <p>Otherwise, run these substeps:

      <ol>
       <li><p>If <a>c</a> is not the <a>EOF code point</a>, not a
       <a lt="URL code points">URL code point</a>, and not
       "<code>%</code>", <a>parse error</a>.

       <li><p>If <a>c</a> is "<code>%</code>" and <a>remaining</a> does
       not start with two <a>ASCII hex digits</a>, <a>parse error</a>.

       <li><p>If <a>c</a> is none of
       <a>EOF code point</a>, U+0009, U+000A, and U+000D,
       <a>utf-8 percent encode</a> <a>c</a> using the
       <a>simple encode set</a>, and append the result to
       <var>url</var>'s
       <a lt='URL scheme data'>scheme data</a>.
      </ol>
    </ol>

   <dt><dfn>no scheme state</dfn>
   <dd>
    <p>If <var>base</var> is null, or <var>base</var>'s
    <a lt='URL scheme'>scheme</a> is not a
    <a>relative scheme</a>, <a>parse error</a>, return failure.

    <p class=note>Due to the <code><a attribute for=URLUtils>protocol</a></code> attribute's
    ability to change <var>base</var>'s
    <a lt='URL scheme'>scheme</a>, <var>base</var>'s
    <a>relative flag</a> is not used here.

    <p>Otherwise, set <var>state</var> to <a>relative state</a>,
    and decrease <var>pointer</var> by one.

   <dt><dfn>relative or authority state</dfn>
   <dd>
    <p>If <a>c</a> is "<code>/</code>" and
    <a>remaining</a> starts with "<code>/</code>", set
    <var>state</var> to <a>authority ignore slashes state</a>
    and increase <var>pointer</var> by one.

    <p>Otherwise, <a>parse error</a>, set <var>state</var> to
    <a>relative state</a> and decrease <var>pointer</var> by
    one.

   <dt><dfn>relative state</dfn>
   <dd>
    <p>Set <var>url</var>'s <a>relative flag</a>, set
    <var>url</var>'s <a lt='URL scheme'>scheme</a> to
    <var>base</var>'s <a lt='URL scheme'>scheme</a> if
    <var>url</var>'s <a lt='URL scheme'>scheme</a> is not
    "<code>file</code>", and then, based on <a>c</a>:

    <dl class=switch>
     <dt><a>EOF code point</a>
     <dd>
      <p>Set <var>url</var>'s <a lt='URL Userinfo'>userinfo</a> to
      <var>base</var>'s <a lt='URL Userinfo'>userinfo</a>,
      <var>url</var>'s <a lt='URL host'>host</a>
      to <var>base</var>'s <a lt='URL host'>host</a>,
      <var>url</var>'s <a lt='URL port'>port</a> to
      <var>base</var>'s <a lt='URL port'>port</a>,
      <var>url</var>'s <a lt='URL path'>path</a> to
      <var>base</var>'s <a lt='URL path'>path</a>, and
      <var>url</var>'s <a lt='URL query'>query</a> to
      <var>base</var>'s <a lt='URL query'>query</a>.

     <dt>"<code>/</code>"
     <dt>"<code>\</code>"
     <dd>
      <ol>
       <li><p>If <a>c</a> is "<code>\</code>",
       <a>parse error</a>.
       <li><p>Set <var>state</var> to
       <a>relative slash state</a>.
      </ol>

     <dt>"<code>?</code>"
     <dd><p>Set
     <var>url</var>'s <a lt='URL Userinfo'>userinfo</a> to
     <var>base</var>'s <a lt='URL Userinfo'>userinfo</a>,
     <var>url</var>'s <a lt='URL host'>host</a> to
     <var>base</var>'s <a lt='URL host'>host</a>,
     <var>url</var>'s <a lt='URL port'>port</a> to
     <var>base</var>'s <a lt='URL port'>port</a>,
     <var>url</var>'s <a lt='URL path'>path</a> to
     <var>base</var>'s <a lt='URL path'>path</a>,
     <var>url</var>'s <a lt='URL query'>query</a> to the empty string,
     and <var>state</var> to <a>query state</a>.

     <dt>"<code>#</code>"
     <dd><p>Set
     <var>url</var>'s <a lt='URL Userinfo'>userinfo</a> to
     <var>base</var>'s <a lt='URL Userinfo'>userinfo</a>,
     <var>url</var>'s <a lt='URL host'>host</a> to
     <var>base</var>'s <a lt='URL host'>host</a>,
     <var>url</var>'s <a lt='URL port'>port</a> to
     <var>base</var>'s <a lt='URL port'>port</a>,
     <var>url</var>'s <a lt='URL path'>path</a> to
     <var>base</var>'s <a lt='URL path'>path</a>,
     <var>url</var>'s <a lt='URL query'>query</a> to
     <var>base</var>'s <a lt='URL query'>query</a>,
     <var>url</var>'s <a lt='URL fragment'>fragment</a> to the empty string,
     and <var>state</var> to <a>fragment state</a>.

     <dt>Otherwise
     <dd>
      <ol>
       <li>
        <p>If <var>url</var>'s <a lt='URL scheme'>scheme</a> is not
        "<code>file</code>", or <var>c</var> is not an
        <a>ASCII alpha</a>, or <a>remaining</a> does not start with either
        "<code>:</code>" or "<code>|</code>", or <a>remaining</a>
        consists of one code point, or <a>remaining</a>'s second code point is
        not one of "<code>/</code>", "<code>\</code>", "<code>?</code>",
        and "<code>#</code>", then set
        <var>url</var>'s <a lt='URL Userinfo'>userinfo</a> to
        <var>base</var>'s <a lt='URL Userinfo'>userinfo</a>,
        <var>url</var>'s <a lt='URL host'>host</a> to
        <var>base</var>'s <a lt='URL host'>host</a>,
        <var>url</var>'s <a lt='URL port'>port</a> to
        <var>base</var>'s <a lt='URL port'>port</a>,
        <var>url</var>'s <a lt='URL path'>path</a> to
        <var>base</var>'s <a lt='URL path'>path</a>, and then remove
        <var>url</var>'s <a lt='URL path'>path</a>'s last entry.
        <!-- base's path cannot be empty so pop does not need a non-empty check -->

        <p class=note>This is a (platform-independent) Windows drive letter quirk.
        When found at the start of a <code>file</code> URL it is treated as an
        absolute path rather than one relative to
        <var>base</var>'s <a lt='URL path'>path</a>.

       <li><p>Set <var>state</var> to <a>relative path state</a>,
       and decrease <var>pointer</var> by one.
      </ol>
    </dl>

   <dt><dfn>relative slash state</dfn>
   <dd>
    <p>If <a>c</a> is either "<code>/</code>" or
    "<code>\</code>", run these steps:

    <ol>
     <li><p>If <a>c</a> is "<code>\</code>",
     <a>parse error</a>.

     <li><p>If <var>url</var>'s
     <a lt='URL scheme'>scheme</a> is
     "<code>file</code>", set <var>state</var> to
     <a>file host state</a>.

     <li><p>Otherwise, set <var>state</var> to
     <a>authority ignore slashes state</a>.
    </ol>

    <p>Otherwise, run these steps:

    <ol>
     <li>
      <p>If <var>url</var>'s <a lt='URL scheme'>scheme</a> is not
      "<code>file</code>", set
      <var>url</var>'s <a lt='URL Userinfo'>userinfo</a> to
      <var>base</var>'s <a lt='URL Userinfo'>userinfo</a>,
      <var>url</var>'s <a lt='URL host'>host</a> to
      <var>base</var>'s <a lt='URL host'>host</a> and
      <var>url</var>'s <a lt='URL port'>port</a> to
      <var>base</var>'s <a lt='URL port'>port</a>.

      <p class="example no-backref"><code>file:/path/</code> will not inherit
      <var>base</var>'s <a lt='URL host'>host</a>.

     <li><p>Set <var>state</var> to <a>relative path state</a>,
     and decrease <var>pointer</var> by one.
    </ol>

   <dt><dfn>authority first slash state</dfn>
   <dd>
    <p>If <a>c</a> is "<code>/</code>", set
    <var>state</var> to <a>authority second slash state</a>.

    <p>Otherwise, <a>parse error</a>, set <var>state</var> to
    <a>authority ignore slashes state</a>, and decrease
    <var>pointer</var> by one.

   <dt><dfn>authority second slash state</dfn>
   <dd>
    <p>If <a>c</a> is "<code>/</code>", set
    <var>state</var> to <a>authority ignore slashes state</a>.

    <p>Otherwise, <a>parse error</a>, set <var>state</var> to
    <a>authority ignore slashes state</a>, and decrease
    <var>pointer</var> by one.

   <dt><dfn>authority ignore slashes state</dfn>
   <dd>
    <p>If <a>c</a> is neither "<code>/</code>" nor
    "<code>\</code>", set <var>state</var> to
    <a>authority state</a>, and decrease <var>pointer</var> by one.

    <p>Otherwise, <a>parse error</a>.

   <dt><dfn>authority state</dfn>
   <dd>
    <ol>
     <li>
      <p>If <a>c</a> is "<code>@</code>", run these substeps:

      <ol>
       <li><p>If the <var>@ flag</var> is set,
       <a>parse error</a>, prepend "<code>%40</code>" to
       <var>buffer</var>.

       <li><p>Set the <var>@ flag</var>.

       <li>
        <p>For each <var>code point</var> in <var>buffer</var>, run these substeps:

        <ol>
         <li><p>If <var>code point</var> is U+0009, U+000A, or U+000D,
         <a>parse error</a>, continue.

         <li><p>If <var>code point</var> is not a
         <a lt="URL code points">URL code point</a> and not
         "<code>%</code>", <a>parse error</a>.

         <li><p>If <var>code point</var> is "<code>%</code>" and
         <a>remaining</a> does not start with two
         <a>ASCII hex digits</a>, <a>parse error</a>.

         <li><p>If <var>code point</var> is "<code>:</code>" and
         <var>url</var>'s
         <a lt='URL password'>password</a> is null, set
         <var>url</var>'s <a lt='URL password'>password</a>
         to the empty string and continue.

         <li><p><a>utf-8 percent encode</a> <var>code point</var> using
         the <a>default encode set</a> and append the result to
         <var>url</var>'s <a lt='URL password'>password</a>
         if <var>url</var>'s <a lt='URL password'>password</a>
         is non-null, and to
         <var>url</var>'s <a lt='URL username'>username</a>
         otherwise.
        </ol>
       <li><p>Set <var>buffer</var> to the empty string.
      </ol>

     <li><p>Otherwise, if <a>c</a> is one of <a>EOF code point</a>,
     "<code>/</code>", "<code>\</code>", "<code>?</code>",
     and "<code>#</code>", decrease <var>pointer</var> by the
     number of code points in <var>buffer</var> plus one, set
     <var>buffer</var> to the empty string, and
     <var>state</var> to <a>host state</a>.

     <li><p>Otherwise, append <a>c</a> to <var>buffer</var>.
    </ol>

   <dt><dfn>file host state</dfn>
   <dd>
    <ol>
     <li>
      <p>If <a>c</a> is one of <a>EOF code point</a>,
      "<code>/</code>", "<code>\</code>", "<code>?</code>",
      and "<code>#</code>", decrease <var>pointer</var> by one,
      and run these substeps:

      <ol>
       <li>
        <p>If <var>buffer</var> consists of two code points, of
        which the first is an <a>ASCII alpha</a> and the second is
        either "<code>:</code>" or "<code>|</code>", set
        <var>state</var> to <a>relative path state</a>.

        <p class=note>This is a (platform-independent) Windows drive letter quirk.
        <var>buffer</var> is not reset here and instead used in the
        <a>relative path state</a>.

       <li><p>Otherwise, if <var>buffer</var> is the empty string, set
       <var>state</var> to <a>relative path start state</a>.

       <li>
        <p>Otherwise, run these steps:

        <ol>
         <li><p>Let <var>host</var> be the result of
         <a lt='host parser'>host parsing</a>
         <var>buffer</var>.

         <li><p>If <var>host</var> is failure, return failure.

         <li><p>Set
         <var>url</var>'s <a lt='URL host'>host</a> to
         <var>host</var>, <var>buffer</var> to the empty string,
         and <var>state</var> to <a>relative path start state</a>.
        </ol>
      </ol>

     <li><p>Otherwise, if <a>c</a> is U+0009, U+000A, or U+000D,
     <a>parse error</a>.

     <li><p>Otherwise, append <a>c</a> to <var>buffer</var>.
    </ol>

   <dt><dfn>host state</dfn>
   <dt><dfn>hostname state</dfn>
   <dd>
    <ol>
     <li>
      <p>If <a>c</a> is "<code>:</code>" and the
      <var>[] flag</var> is unset, run these substeps:

      <ol>
       <li><p>Let <var>host</var> be the result of
       <a lt='host parser'>host parsing</a>
       <var>buffer</var>.

       <li><p>If <var>host</var> is failure, return failure.

       <li><p>Set <var>url</var>'s <a lt='URL host'>host</a> to
       <var>host</var>, <var>buffer</var> to the empty string,
       and <var>state</var> to <a>port state</a>.

       <li><p>If <var>state override</var> is <a>hostname state</a>,
       terminate this algorithm.
      </ol>

     <li>
      <p>Otherwise, if <a>c</a> is the
      <a>EOF code point</a>, "<code>/</code>",
      "<code>\</code>", "<code>?</code>", or
      "<code>#</code>", decrease <var>pointer</var> by one, and
      run these substeps:

      <ol>
       <li><p>Let <var>host</var> be the result of
       <a lt='host parser'>host parsing</a>
       <var>buffer</var>.

       <li><p>If <var>host</var> is failure, return failure.

       <li><p>Set <var>url</var>'s <a lt='URL host'>host</a> to
       <var>host</var>, <var>buffer</var> to the empty string,
       and <var>state</var> to <a>relative path start state</a>.

       <li><p>If <var>state override</var> is given, terminate this
       algorithm.
      </ol>

     <li><p>Otherwise, if <a>c</a> is U+0009, U+000A, or U+000D,
     <a>parse error</a>.

     <li>
      <p>Otherwise, run these substeps:

      <ol>
       <li><p>If <a>c</a> is "<code>[</code>", set the
       <var>[] flag</var>.

       <li><p>If <a>c</a> is "<code>]</code>", unset the
       <var>[] flag</var>.

       <li><p>Append <a>c</a> to <var>buffer</var>.
      </ol>
    </ol>

   <dt><dfn>port state</dfn>
   <dd>
    <ol>
     <li><p>If <a>c</a> is an <a lt="ASCII digits">ASCII digit</a>,
     append <a>c</a> to <var>buffer</var>.

     <li>
      <p>Otherwise, if <a>c</a> is one of
      <a>EOF code point</a>, "<code>/</code>",
      "<code>\</code>", "<code>?</code>", and
      "<code>#</code>", or <var>state override</var> is given, run
      these substeps:
      <ol>
       <li>
        <p>Remove leading U+0030 code points from <var>buffer</var>
        until either the leading code point is not U+0030 or
        <var>buffer</var> is one code point.

        <div class=example><!-- putting class=example on table has side effects -->
        <table>
         <tr><th>Input<th>Output
         <tr><td>"<code>42</code>"<td>"<code>42</code>"
         <tr><td>"<code>031</code>"<td>"<code>31</code>"
         <tr><td>"<code>080</code>"<td>"<code>80</code>"
         <tr><td>"<code>0000</code>"<td>"<code>0</code>"
        </table>
        </div>

       <li><p>If <var>buffer</var> is equal to
       <var>url</var>'s <a lt='URL scheme'>scheme</a>'s
       <a>default port</a>, set <var>buffer</var> to the empty
       string.

       <li><p>Set <var>url</var>'s
       <a lt='URL port'>port</a> to <var>buffer</var>.

       <li><p>If <var>state override</var> is given, terminate this
       algorithm.

       <li><p>Set <var>buffer</var> to the empty string,
       <var>state</var> to <a>relative path start state</a>, and
       decrease <var>pointer</var> by one.
      </ol>

     <li><p>Otherwise, if <a>c</a> is U+0009, U+000A, or U+000D,
     <a>parse error</a>.

     <li><p>Otherwise, <a>parse error</a>, return failure.
    </ol>

   <dt><dfn>relative path start state</dfn>
   <dd>
    <ol>
     <li><p>If <a>c</a> is "<code>\</code>",
     <a>parse error</a>.

     <li><p>Set <var>state</var> to <a>relative path state</a>
     and if <a>c</a> is neither "<code>/</code>" nor
     "<code>\</code>", decrease <var>pointer</var> by one.
    </ol>

   <dt><dfn>relative path state</dfn>
   <dd>
    <ol>
     <li>
      <p>If either <a>c</a> is one of
      <a>EOF code point</a>, "<code>/</code>", and
      "<code>\</code>", or <var>state override</var> is not given and
      <a>c</a> is one of "<code>?</code>" and
      "<code>#</code>", run these substeps:
      <ol>
       <li><p>If <a>c</a> is "<code>\</code>", <a>parse error</a>.

       <li>
        <p>If <var>buffer</var>, lowercased, matches any row in the first column of
        the following table, set <var>buffer</var> to the contents of the cell in
        the second column of the matched row:

        <table>
         <tr><td>"<code>%2e</code>"   <td>"<code>.</code>"
         <tr><td>"<code>.%2e</code>"  <td rowspan=3>"<code>..</code>"
         <tr><td>"<code>%2e.</code>"
         <tr><td>"<code>%2e%2e</code>"
        </table>

       <li><p>If <var>buffer</var> is "<code>..</code>", remove
       <var>url</var>'s <a lt='URL path'>path</a>'s last entry, if
       any, and then if <a>c</a> is neither  "<code>/</code>" nor
       "<code>\</code>", append the empty string to <var>url</var>'s
       <a lt='URL path'>path</a>.

       <li><p>Otherwise, if <var>buffer</var> is "<code>.</code>" and
       <a>c</a> is neither "<code>/</code>" nor "<code>\</code>",
       append an empty string to
       <var>url</var>'s <a lt='URL path'>path</a>.

       <li>
        <p>Otherwise, if <var>buffer</var> is not
        "<code>.</code>", run these subsubsteps:

        <ol>
         <li>
          <p>If <var>url</var>'s <a lt='URL scheme'>scheme</a> is
          "<code>file</code>", <var>url</var>'s <a lt='URL path'>path</a>
          is empty, <var>buffer</var> consists of two
          code points, of which the first is an <a>ASCII alpha</a>,
          and the second is "<code>|</code>", replace the second code point in
          <var>buffer</var> with "<code>:</code>".

          <p class=note>This is a (platform-independent) Windows drive letter quirk.
          They are beautiful, no?

         <li><p>Append <var>buffer</var> to
         <var>url</var>'s <a lt='URL path'>path</a>.
        </ol>

       <li><p>Set <var>buffer</var> to the empty string.

       <li><p>If <a>c</a> is "<code>?</code>", set
       <var>url</var>'s <a lt='URL query'>query</a> to the empty string,
       and <var>state</var> to <a>query state</a>.

       <li><p>If <a>c</a> is "<code>#</code>", set
       <var>url</var>'s <a lt='URL fragment'>fragment</a> to the empty string,
       and <var>state</var> to <a>fragment state</a>.
      </ol>

     <li><p>Otherwise, if <a>c</a> is U+0009, U+000A, or U+000D,
     <a>parse error</a>.

     <li>
      <p>Otherwise, run these steps:

      <ol>
       <li><p>If <a>c</a> is not a
       <a lt="URL code points">URL code point</a> and not "<code>%</code>",
       <a>parse error</a>.

       <li><p>If <a>c</a> is "<code>%</code>" and <a>remaining</a> does
       not start with two <a>ASCII hex digits</a>, <a>parse error</a>.

       <li><p><a>utf-8 percent encode</a> <a>c</a> using the
       <a>default encode set</a>, and append the result to
       <var>buffer</var>.
      </ol>
    </ol>

   <dt><dfn>query state</dfn>
   <dd>
    <ol>
     <li>
      <p>If <a>c</a> is the <a>EOF code point</a>, or
      <var>state override</var> is not given and <a>c</a>
      is "<code>#</code>", run these substeps:

      <ol>
       <li><p>If <var>url</var>'s <a>relative flag</a> is unset or
       <var>url</var>'s <a lt='URL scheme'>scheme</a> is either
       "<code>ws</code>" or "<code>wss</code>", set
       <var>encoding override</var> to <a>utf-8</a>.
       <!-- https://simon.html5.org/test/url/url-encoding.html -->

       <li><p>Set <var>buffer</var> to the result of
       <a lt='encode'>encoding</a>
       <var>buffer</var> using <var>encoding override</var>.

       <li>
        <p>For each <var>byte</var> in <var>buffer</var> run
        these subsubsteps:

        <ol>
         <li><p>If <var>byte</var> is less than 0x21, greater than
         0x7E, or is one of 0x22, 0x23, 0x3C, 0x3E, and 0x60, append
         <var>byte</var>,
         <a lt="percent encode">percent encoded</a>, to
         <var>url</var>'s <a lt='URL query'>query</a>.

         <li><p>Otherwise, append a code point whose value is
         <var>byte</var> to <var>url</var>'s
         <a lt='URL query'>query</a>.
        </ol>

       <li><p>Set <var>buffer</var> to the empty string.

       <li><p>If <a>c</a> is "<code>#</code>", set
       <var>url</var>'s
       <a lt='URL fragment'>fragment</a> to the empty string,
       and state to <a>fragment state</a>.
      </ol>

     <li><p>Otherwise, if <a>c</a> is U+0009, U+000A, or U+000D,
     <a>parse error</a>.

     <li>
      <p>Otherwise, run these substeps:

      <ol>
       <li><p>If <a>c</a> is not a
       <a lt="URL code points">URL code point</a> and not "<code>%</code>",
       <a>parse error</a>.

       <li><p>If <a>c</a> is "<code>%</code>" and <a>remaining</a> does
       not start with two <a>ASCII hex digits</a>, <a>parse error</a>.

       <li><p>Append <a>c</a> to <var>buffer</var>.
      </ol>
    </ol>

   <dt><dfn>fragment state</dfn>
   <dd>
    <p>Based on <a>c</a>:
    <dl class=switch>
     <dt><a>EOF code point</a>
     <dd><p>Do nothing.

     <dt>U+0000
     <dt>U+0009
     <dt>U+000A
     <dt>U+000D
     <dd><p><a>Parse error</a>.

     <dt>Otherwise
     <dd>
      <ol>
       <li><p>If <a>c</a> is not a <a lt="URL code points">URL code point</a> and not
       "<code>%</code>", <a>parse error</a>.

       <li><p>If <a>c</a> is "<code>%</code>" and <a>remaining</a> does
       not start with two <a>ASCII hex digits</a>, <a>parse error</a>.

       <li>
        <p>Append <a>c</a> to <var>url</var>'s <a lt="URL fragment">fragment</a>.

        <p class=note>Unfortunately not using <a lt="percent encode">percent-encoding</a> is intentional as
        implementations with majority market share exhibit this behavior.
        <!-- Chrome does percent-encoding if the scheme is not a relative scheme,
             hopefully that can be aligned since flip-flopping is not great. -->
      </ol>
    </dl>
  </dl>

 <li><p>Return <var>url</var>.
</ol>

<hr>

<p>To <dfn>set the username</dfn> given a <var>url</var> and
<var>username</var>, run these steps:

<ol>
 <li><p>Set <var>url</var>'s <a lt='URL username'>username</a> to the
 empty string.

 <li><p>For each code point in <var>username</var>,
 <a>utf-8 percent encode</a> it using the <a>username encode set</a>, and
 append the result to <var>url</var>'s
 <a lt='URL username'>username</a>.
</ol>

<p>To <dfn>set the password</dfn> given a <var>url</var> and
<var>password</var>, run these steps:

<ol>
 <li><p>If <var>password</var> is the empty string, set <var>url</var>'s
 <a lt='URL password'>password</a> to null.

 <li>
  <p>Otherwise, run these substeps:

  <ol>
   <li><p>Set <var>url</var>'s <a lt='URL password'>password</a> to
   the empty string.

   <li><p>For each code point in <var>password</var>,
   <a>utf-8 percent encode</a> it using the <a>password encode set</a>, and
   append the result to <var>url</var>'s
   <a lt='URL password'>password</a>.
  </ol>
</ol>


<h3 id=url-serializing>URL serializing</h3>

<p>The <dfn id=concept-url-serializer lt='URL serializer'>URL serializer</dfn> takes a
<a>URL</a> <var>url</var>,
optionally an <i title>exclude fragment flag</i>, and then runs these steps:

<ol>
 <li><p>Let <var>output</var> be <var>url</var>'s
 <a lt='URL scheme'>scheme</a> and
 "<code>:</code>" concatenated.

 <li>
  <p>If <var>url</var>'s <a>relative flag</a> is set:

  <ol>
   <li><p>Append "<code>//</code>" to <var>output</var>.

   <li>
    <p>If <var>url</var>'s
    <a lt='URL username'>username</a> is not the empty string
    or <var>url</var>'s
    <a lt='URL password'>password</a> is non-null, run these
    substeps:

    <ol>
     <li><p>Append <var>url</var>'s
     <a lt='URL username'>username</a> to
     <var>output</var>.

     <li><p>If <var>url</var>'s
     <a lt='URL password'>password</a> is non-null, append
     "<code>:</code>" concatenated with <var>url</var>'s
     <a lt='URL password'>password</a> to
     <var>output</var>.

     <li><p>Append "<code>@</code>" to <var>output</var>.
    </ol>

   <li><p>Append <var>url</var>'s
   <a lt='URL host'>host</a>,
   <a lt='host serializer'>serialized</a>, to
   <var>output</var>.

   <li><p>If <var>url</var>'s <a lt='URL port'>port</a>
   is not the empty string, append "<code>:</code>" concatenated with
   <var>url</var>'s <a lt='URL port'>port</a> to
   <var>output</var>.

   <li><p>Append "<code>/</code>" concatenated with the strings in
   <var>url</var>'s <a lt='URL path'>path</a>
   (including empty strings), separated from each other by
   "<code>/</code>" to <var>output</var>.
  </ol>

 <li><p>Otherwise, if <var>url</var>'s <a>relative flag</a> is
 unset, append <var>url</var>'s
 <a lt='URL scheme data'>scheme data</a> to
 <var>output</var>.

 <li><p>If <var>url</var>'s <a lt='URL query'>query</a> is non-null,
 append "<code>?</code>" concatenated with <var>url</var>'s
 <a lt='URL query'>query</a> to <var>output</var>.

 <li><p>If the <i title>exclude fragment flag</i> is unset and
 <var>url</var>'s <a lt='URL fragment'>fragment</a> is
 non-null, append  "<code>#</code>" concatenated with
 <var>url</var>'s <a lt='URL fragment'>fragment</a> to
 <var>output</var>.

 <li><p>Return <var>output</var>.
</ol>

<h3 id=origin>Origin</h3>
<!-- Still need to watch the final bits -->

<p class=note>See <a spec=html>origin</a>'s definition in HTML for the
necessary background information. [[!HTML]]

<p>A <a>URL</a>'s <dfn id=concept-url-origin lt='URL origin'>origin</dfn> is
the <a spec=html>origin</a> returned by running these steps, switching
on <a>URL</a>'s <a lt='URL scheme'>scheme</a>:

<dl class=switch>
 <dt>"<code>blob</code>"
 <dd>
  <p>Let <var>url</var> be the result of
  <a lt='basic URL parser'>parsing</a>
  <a>URL</a>'s
  <a lt='URL scheme data'>scheme data</a>.

  <p>If <var>url</var> is failure, return a new globally unique identifier.
  Otherwise, return <var>url</var>'s <a lt='URL origin'>origin</a>.
  <!-- Did you mean: recursion -->

  <p class="example no-backref">The <a lt='URL origin'>origin</a> of
  <code>blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f</code> is
  the tuple
  (<code>https</code>, <code>whatwg.org</code>, <code>443</code>).

 <dt>"<code>ftp</code>"
 <dt>"<code>gopher</code>"
 <dt>"<code>http</code>"
 <dt>"<code>https</code>"
 <dt>"<code>ws</code>"
 <dt>"<code>wss</code>"
 <dd><p>Return a tuple consisting of <a>URL</a>'s
 <a lt='URL scheme'>scheme</a>, its
 <a lt='URL host'>host</a>, and its <a>default port</a> if its
 <a lt='URL port'>port</a> is the empty string, and its
 <a lt='URL port'>port</a> otherwise.

 <dt>"<code>file</code>"
 <dd><p>Unfortunate as it is, this is left as an exercise to the reader. When in doubt,
 return a new globally unique identifier.

 <dt>Otherwise
 <dd><p>Return a new globally unique identifier.
</dl>


<h2 id="application/x-www-form-urlencoded"><code lt=application-x-www-form-urlencoded-0><a>application/x-www-form-urlencoded</a></code></h2>

<p>The <dfn id=application-x-www-form-urlencoded-0><code>application/x-www-form-urlencoded</code></dfn> format is a simple way to
encode name-value pairs in a byte sequence where all bytes are in the 0x00 to 0x7F range.

<p class="note no-backref">While this description makes
<code lt=application-x-www-form-urlencoded-0><a>application/x-www-form-urlencoded</a></code> sound dated — and really, it is — the
format is in widespread use due to its prevalence of HTML forms.
[[!HTML]]

<h3 id=urlencoded-parsing><code lt=application-x-www-form-urlencoded-0>application/x-www-form-urlencoded</code> parsing</h3>

<p class="note no-backref">The features provided by the
<code lt=application-x-www-form-urlencoded-0><a lt='urlencoded parser'>application/x-www-form-urlencoded</a></code> parser</a>
are mainly relevant for server-oriented implementations. A browser-based implementation
only needs what the
<code lt=application-x-www-form-urlencoded-0><a lt='urlencoded string parser'>application/x-www-form-urlencoded</a></code> string parser</a>
requires.

<p>The
<dfn id=concept-urlencoded-parser lt='urlencoded parser'><code lt=application-x-www-form-urlencoded-0><a>application/x-www-form-urlencoded</a></code> parser</dfn>
takes a byte sequence <var>input</var>, optionally with an
<a>encoding</a> <var>encoding override</var>,
optionally with a <i title>use _charset_ flag</i>, and optionally with an
<i title>isindex flag</i>, and then runs these steps:

<ol>
 <li><p>If <var>encoding override</var> is not given, set it to
 <a>utf-8</a>.

 <li>
  <p>If <var>encoding override</var> is not
  <a>utf-8</a> and <var>input</var> contains bytes
  whose value is greater than 0x7F, return failure.

  <p class="note no-backref">This can only happen if <var>input</var> was not
  generated through the <a lt='urlencoded serializer'>serializer</a> or
  <code><a interface>URLSearchParams</a></code>.

 <li><p>Let <var>sequences</var> be the result of splitting
 <var>input</var> on `<code>&</code>`.
 <!-- XXX define splitting? DOM does not do it -->

 <li><p>If the <i title>isindex flag</i> is set and the first byte sequence in
 <var>sequences</var> does not contain a `<code>=</code>`, prepend
 `<code>=</code>` to the first byte sequence in <var>sequences</var>.

 <li><p>Let <var>pairs</var> be an empty list of name-value pairs where both name
 and value hold a byte sequence.

 <li>
  <p>For each byte sequence <var>bytes</var> in <var>sequences</var>,
  run these substeps:

  <ol>
   <li><p>If <var>bytes</var> is the empty byte sequence, run these substeps for the
   next byte sequence.

   <li><p>If <var>bytes</var> contains a `<code>=</code>`, then let
   <var>name</var> be the bytes from the start of <var>bytes</var> up to but
   excluding its first `<code>=</code>`, and let <var>value</var> be the
   bytes, if any, after the first `<code>=</code>` up to the end of
   <var>bytes</var>. If `<code>=</code>` is the first byte, then
   <var>name</var> will be the empty byte sequence. If it is the last, then
   <var>value</var> will be the empty byte sequence.

   <li><p>Otherwise, let <var>name</var> have the value of <var>bytes</var>
   and let <var>value</var> be the empty byte sequence.

   <li><p>Replace any `<code>+</code>` in <var>name</var> and
   <var>value</var> with 0x20.

   <li>
    <p>If <i title>use _charset_ flag</i> is set, <var>name</var> is
    `<code>_charset_</code>`, run these substeps:

    <ol>
     <li><p>Let <var>result</var> be the result of
     <a lt=concept-encoding-get>getting an encoding</a>
     for <var>value</var>,
     <a lt="utf-8 decode without BOM">decoded</a>.

     <li><p>If <var>result</var> is not failure, unset <i title>use _charset_ flag</i> and
     set <var>encoding override</var> to <var>result</var>.
    </ol>

   <li><p>Add a pair consisting of <var>name</var> and
   <var>value</var> to <var>pairs</var>.
  </ol>

 <li><p>Let <var>output</var> be an empty list of name-value pairs where both name
 and value hold a string.

 <li><p>For each name-value pair in <var>pairs</var>, append a name-value pair to
 <var>output</var> where the new name and value appended to <var>output</var>
 are the result of running <var>encoding override</var>'s
 <a>decoder</a> on the
 <a lt="percent decode">percent decoding</a> of the name and value from
 <var>pairs</var>, respectively.

 <li><p>Return <var>output</var>.
</ol>

<h3 id=urlencoded-serializing><code lt=application-x-www-form-urlencoded-0>application/x-www-form-urlencoded</code> serializing</h3>

<p>The
<dfn id=concept-urlencoded-byte-serializer lt='urlencoded byte serializer'><code lt=application-x-www-form-urlencoded-0><a>application/x-www-form-urlencoded</a></code> byte serializer</dfn>
takes a byte sequence <var>input</var> and then runs these steps:

<ol>
 <li><p>Let <var>output</var> be the empty string.
 <li>
  <p>For each byte in <var>input</var>, depending on
  <var>byte</var>:

  <dl>
   <dt>0x20
   <dd><p>Append U+002B to <var>output</var>.

   <dt>0x2A
   <dt>0x2D
   <dt>0x2E
   <dt>0x30 to 0x39
   <dt>0x41 to 0x5A
   <dt>0x5F
   <dt>0x61 to 0x7A
   <dd><p>Append a code point whose value is <var>byte</var> to
   <var>output</var>.

   <dt>Otherwise
   <dd><p>Append <var>byte</var>,
   <a lt="percent encode">percent encoded</a>, to
   <var>output</var>.
  </dl>
 <li><p>Return <var>output</var>.
</ol>
<!-- The inverse of the above byte set is all bytes
     less than 0x20,
     0x21 to 0x29,
     0x2B,
     0x2C,
     0x2F,
     0x3A to 0x40,
     0x5B to 0x5E,
     0x60,
     bytes greater than 0x7A -->

<p>The
<dfn id=concept-urlencoded-serializer lt='urlencoded serializer'><code lt=application-x-www-form-urlencoded-0><a>application/x-www-form-urlencoded</a></code> serializer</dfn>
takes a list of name-value pairs <var>pairs</var>, optionally with an
<a>encoding</a>
<var>encoding override</var>, and then runs these steps:

<ol>
 <li><p>If <var>encoding override</var> is not given, set it to
 <a>utf-8</a>.

 <li><p>Let <var>output</var> be the empty string.

 <li>
  <p>For each <var>pair</var> in <var>pairs</var>, run
  these substeps:

  <ol>
   <li><p>Let <var>outputPair</var> be a copy of <var>pair</var>.

   <li><p>Replace <var>outputPair</var>'s name and value with the result of running
   <a>encode</a> on them using
   <var>encoding override</var>, respectively.

   <li><p>Replace <var>outputPair</var>'s name and value with their
   <a lt='urlencoded byte serializer'>serialization</a>.

   <li><p>If <var>pair</var> is not the first pair in <var>pairs</var>, append
   "<code>&</code>" to <var>output</var>.

   <li><p>Append <var>outputPair</var>'s name, followed by "<code>=</code>",
   followed by <var>outputPair</var>'s value to <var>output</var>.
  </ol>

 <li>Return <var>output</var>.
</ol>

<h3 id=urlencoded-hooks>Hooks</h3>

<p>The
<dfn id=concept-urlencoded-string-parser lt='urlencoded string parser'><code lt=application-x-www-form-urlencoded-0><a>application/x-www-form-urlencoded</a></code> string parser</dfn>
takes a string <var>input</var>,
<a lt="utf-8 encode">utf-8 encodes</a> it, and then
returns the result of
<code lt=application-x-www-form-urlencoded-0><a lt='urlencoded parser'>application/x-www-form-urlencoded</a></code> parsing</a>
it.



<h2 id=api>API</h2>

<pre class=idl>[Constructor(USVString url, optional USVString base),
 Exposed=(Window,Worker)]
interface URL {
  static USVString domainToASCII(USVString domain);
  static USVString domainToUnicode(USVString domain);
};
URL implements URLUtils;

[NoInterfaceObject,
 Exposed=(Window,Worker)]
interface URLUtils {
  stringifier attribute USVString href;
  readonly attribute USVString origin;

           attribute USVString protocol;
           attribute USVString username;
           attribute USVString password;
           attribute USVString host;
           attribute USVString hostname;
           attribute USVString port;
           attribute USVString pathname;
           attribute USVString search;
           attribute URLSearchParams searchParams;
           attribute USVString hash;
};

[NoInterfaceObject,
 Exposed=(Window,Worker)]
interface URLUtilsReadOnly {
  stringifier readonly attribute USVString href;
  readonly attribute USVString origin;

  readonly attribute USVString protocol;<!--
  readonly attribute USVString username;
  readonly attribute USVString password;-->
  readonly attribute USVString host;
  readonly attribute USVString hostname;
  readonly attribute USVString port;
  readonly attribute USVString pathname;
  readonly attribute USVString search;<!--
  readonly attribute URLSearchParams searchParams;-->
  readonly attribute USVString hash;
};</pre>

<p>Except where different objects implementing {{URLUtilsReadOnly}} are identical to
objects implementing {{URLUtils}}.

<p class=note>Since all members are readonly and certain members from {{URLUtils}} are not
exposed a number of potential optimizations is possible compared to objects implementing
{{URLUtils}}. These are left as an exercise to the reader.

<!-- XXX Ideas:
  boolean isEqual(URL, optional URLEqualOptions options)
           attribute URLPath segments;

dictionary URLEqualOptions {
  boolean percentEncoding = false;
  boolean ignoreHash = false;
  boolean ignoreDomainDot = false;
  ...
};

URLPath would be a subclassed Array? -->

<p>Specifications defining objects implementing {{URLUtils}} or {{URLUtilsReadOnly}} must
define a <dfn id=concept-urlutils-get-the-base>get the base</dfn> algorithm, which must
return the appropriate <a>base URL</a> for the object.

<p>Specifications defining objects implementing {{URLUtils}} may define
<dfn id=concept-urlutils-update lt='URLUtils update'>update steps</dfn> to make it
possible for an underlying string (such as an
<a lt=concept-attribute-value>attribute value</a>)
to be updated. The <a lt='URLUtils update'>update steps</a> are passed a string
<var>value</var> for this purpose.

<p>An object implementing {{URLUtils}} or {{URLUtilsReadOnly}} has an
associated <dfn id=concept-urlutils-input lt='URLUtils input'>input</dfn> (a string),
<dfn id=concept-urlutils-query-encoding lt='URLUtils query encoding'>query encoding</dfn>
(an <a>encoding</a>),
<dfn id=concept-urlutils-query-object lt='URLUtils query object'>query object</dfn>
(a {{URLSearchParams}} object or null), and a
<dfn id=concept-urlutils-url lt='URLUtils URL'>url</dfn> (a <a>URL</a> or null).

Unless stated otherwise, <a lt='URLUtils query encoding'>query encoding</a> is
<a>utf-8</a> and
<a lt='URLUtils query object'>query object</a> is null. The others follow
from the <a lt='URLUtils set the input'>set the input</a> algorithm.

<p class=note>The associated
<a lt='URLUtils query encoding'>query encoding</a> is a legacy
concept only relevant for HTML.
[[!HTML]]

<p>Specifications defining objects implementing {{URLUtils}} or {{URLUtilsReadOnly}} must
use the <a lt='URLUtils set the input'>set the input</a> algorithms to set
<a lt='URLUtils input'>input</a>, <a lt='URLUtils URL'>url</a>, and
<a lt='URLUtils query object'>query object</a>. To
<dfn id=concept-urlutils-set-the-input lt='URLUtils set the input'>set the input</dfn>
given <var>input</var> and optionally a <var>url</var>, run these steps:

<ol>
 <li><p>If <var>url</var> is given, set <a lt='URLUtils URL'>url</a>
 to <var>url</var> and <a lt='URLUtils input'>input</a> to
 <var>input</var>.

 <li>
  <p>Otherwise, run these substeps:

  <ol>
   <li><p>Set <a lt='URLUtils URL'>url</a> to null.

   <li><p>If <var>input</var> is null, set
   <a lt='URLUtils input'>input</a> to the empty string.

   <li>
    <p>Otherwise, run these subsubsteps:

    <ol>
     <li><p>Set <a lt='URLUtils input'>input</a> to <var>input</var>.

     <li><p>Let <var>url</var> be the result of running the
     <a>URL parser</a> on
     <a lt='URLUtils input'>input</a> with
     <a>base URL</a> being the result of running
     <a>get the base</a> and
     <a lt='URLUtils query encoding'>query encoding</a> as
     <var>encoding override</var>.
     <!-- support blob URLs at this level -->

     <li><p>If <var>url</var> is not failure, set
     <a lt='URLUtils URL'>url</a> to <var>url</var>.
    </ol>
  </ol>

 <li><p>Let <var>query</var> be <a lt="URLUtils URL">url</a>'s <a lt="URL query">query</a>
 if <a lt="URLUtils URL">url</a> and its <a lt="URL query">query</a> are non-null, and the
 empty string otherwise.

 <li><p>If <a lt='URLUtils query object'>query object</a> is null, set
 <a lt='URLUtils query object'>query object</a> to a
 <a lt='URLSearchParams new'>new <code>URLSearchParams</code> object</a>
 using <var>query</var>, and then append the
 <a>context object</a> to
 <a lt='URLUtils query object'>query object</a>'s list of
 <a lt='URLSearchParams URL object'>url objects</a>.

 <li><p>Otherwise, set <a lt='URLUtils query object'>query object</a>'s
 <a lt='URLSearchParams list'>list</a> to the result of
 <a lt='urlencoded string parser'>parsing</a> <var>query</var>.
</ol>

<p>To run the <dfn>pre-update steps</dfn> for an object implementing {{URLUtils}},
optionally given a <var>value</var>, run these steps:

<ol>
 <li><p>If <var>value</var> is not given, let <var>value</var> be the result
 of <a lt='URL serializer'>serializing</a> the associated
 <a lt='URLUtils URL'>url</a>.
 <!-- these steps are always invoked with a value if url can be null -->

 <li><p>Run the <a lt='URLUtils update'>update steps</a> with
 <var>value</var>.
</ol>


<h3 id=constructors>Constructors</h3> <!-- "constructor" causes dfn.js to fail -->

<p>The
<dfn constructor dfn-for=URL><code>URL(<var>url</var>, <var>base</var>)</code></dfn>
constructor, when invoked, must run these steps:

<ol>
 <li><p>Let <var>parsedBased</var> be null.

 <li>
  <p>If <var>base</var> is given, run these substeps:

  <ol>
   <li><p>Let <var>parsedBase</var> be the result of running the <a>basic URL parser</a>
   on <var>base</var>.

   <li><p>If <var>parsedBase</var> is failure, <a>throw</a> a <code>TypeError</code>
   exception.
  </ol>

 <li><p>Let <var>parsedURL</var> be the result of running the <a>basic URL parser</a> on
 <var>url</var> with <var>parsedBase</var>.

 <li><p>If <var>parsedURL</var> is failure, <a>throw</a> a <code>TypeError</code>
 exception.

 <li><p>Let <var>result</var> be a new {{URL}} object.

 <li><p>Let <var>result</var>'s <a>get the base</a> return <var>parsedBase</var>.

 <li>
  <p>Run <var>result</var>'s
  <a lt='URLUtils set the input'>set the input</a> given the empty string
  and <var>parsedURL</var>.

  <p class="note no-backref">A {{URL}} object's
  <a lt='URLUtils input'>input</a> is never exposed.

 <li><p>Return <var>result</var>.
</ol>

<div class=example>
 <p>To <a lt='basic URL parser'>Basic URL parse</a> a string into a
 <a>URL</a> without using a
 <a>base URL</a>, invoke the constructor with a single
 argument:

 <pre>var input = "https://example.org/💩",
    url = new URL(input)
url.pathname // "/%F0%9F%92%A9"</pre>

 <p>Alternatively you can use the <a>base URL</a> of a
 <a lt=concept-document>document</a> through
 <code><a lt=dom-Node-baseURI>baseURI</a></code>:

 <pre>var input = "/💩",
    url = new URL(input, document.baseURI)
url.href // "https://url.spec.whatwg.org/%F0%9F%92%A9"</pre>
</div>


<h3 id=url-statics>{{URL}} statics</h3>

<p>The
<dfn method dfn-for=URL><code>domainToASCII(<var>domain</var>)</code></dfn>
static method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>asciiDomain</var> be the result of
 <a lt='host parser'>host parsing</a> <var>domain</var>.

 <li><p>If <var>asciiDomain</var> is an <a lt='IPv6'>IPv6 address</a>
 or failure, return the empty string.

 <li><p>Return <var>asciiDomain</var>.
</ol>

<p>The
<dfn method dfn-for=URL><code>domainToUnicode(<var>domain</var>)</code></dfn>
static method, when invoked, must run these steps:

<ol>
 <li><p>Let <var>unicodeDomain</var> be the result of
 <a lt='host parser'>host parsing</a> <var>domain</var> with the
 <var>Unicode flag</var> set.

 <li><p>If <var>unicodeDomain</var> is an
 <a lt='IPv6'>IPv6 address</a> or failure, return the empty string.

 <li><p>Return <var>unicodeDomain</var>.
</ol>

<p class=XXX>Add domainToUI() which follows the UA conventions for when to use the Unicode
representation?


<h3 id=urlutils-and-urlutilsreadonly-members>{{URLUtils}} and {{URLUtilsReadOnly}} members</h3>

<p class=note>The {{URLUtils}} and {{URLUtilsReadOnly}} interfaces are
not exposed on the global object. They are meant to augment other objects, such as
{{URL}}.

<p>The <dfn attribute dfn-for=URLUtils><code>href</code></dfn> attribute's getter must run
these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, return
 <a lt='URLUtils input'>input</a>.

 <li><p>Return the <a lt='URL serializer'>serialization</a>
 of <a lt='URLUtils URL'>url</a>.
</ol>

<p>The <code><a attribute for=URLUtils>href</a></code> attribute's setter must run these steps:

<ol>
 <li><p>Let <var>input</var> be the given value.

 <li>
  <p>If the <code><a>context object</a></code> is a {{URL}} object, run these substeps:

  <ol>
   <li><p>Let <var>parsedURL</var> be the result of running the
   <a>basic URL parser</a> on <var>input</var>
   with <a>base URL</a> being the result of running
   <a>get the base</a>.

   <li><p>If <var>parsedURL</var> is failure,
   <a>throw</a> a <code>TypeError</code> exception.

   <li>
    <p>Run <a lt='URLUtils set the input'>set the input</a> given the empty
    string and <var>parsedURL</var>.

    <p class="note no-backref">A {{URL}} object's <a lt='URLUtils input'>input</a> is
    never exposed.
  </ol>

 <li>
  <p>Otherwise, run these substeps:

  <ol>
   <li><p>Run the <a lt='URLUtils set the input'>set the input</a>
   algorithm for <var>input</var>.

   <li><p>Run the <a>pre-update steps</a> with the <var>input</var>.
  </ol>

  <div class=example>
   <p>This means that if the <code><a attribute for=URLUtils>href</a></code> attribute is set to
   value that would cause the <a>URL parser</a> to return
   failure, that value is still passed through unchanged. This is one of those unfortunate
   legacy incidents.

   <pre>var a = document.createElement("a"),
    input = "https://test:test/" // invalid port makes the parser return failure
a.href = test
a.href === test // true</pre>
  </div>
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>origin</code></dfn> attribute's getter must
run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, return the empty
 string.

 <li><p>Return the
 <a lt="Unicode serialisation of an origin">Unicode serialization</a>
 of <a lt='URLUtils URL'>url</a>'s <a lt='URL origin'>origin</a>.
 [[!HTML]]
</ol>

<p class=note>It returns the Unicode rather than the ASCII serialization for
compatibility with HTML's <code>MessageEvent</code> feature.
[[!HTML]]

<p>The <dfn attribute dfn-for=URLUtils><code>protocol</code></dfn> attribute's getter
must run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, return
 "<code>:</code>".

 <li><p>Return <a lt='URL scheme'>scheme</a> and
 "<code>:</code>" concatenated.
</ol>

<p>The <code><a attribute for=URLUtils>protocol</a></code> attribute's setter must
run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, terminate
 these steps.

 <li><p><a lt='basic URL parser'>Basic URL parse</a> the given value and
 "<code>:</code>" concatenated with
 <a lt='URLUtils URL'>url</a> as <var>url</var> and
 <a>scheme start state</a> as <var>state override</var>.

 <li><p>Run the <a>pre-update steps</a>.
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>username</code></dfn> attribute's getter
must run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, return the
 empty string.

 <li><p>Return <a lt='URL username'>username</a>.
</ol>

<p>The <code><a attribute for=URLUtils>username</a></code> attribute's setter must
run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, or its
 <a>relative flag</a> is unset, terminate these steps.

 <li><p><a>Set the username</a> given <a lt='URLUtils URL'>url</a>
 and the given value.

 <li><p>Run the <a>pre-update steps</a>.
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>password</code></dfn> attribute's getter
must run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null or its
 <a lt='URL password'>password</a> is null, return the empty
 string.

 <li><p>Return <a lt='URL password'>password</a>.
</ol>

<p>The <code><a attribute for=URLUtils>password</a></code> attribute's setter must
run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, or its
 <a>relative flag</a> is unset, terminate these steps.

 <li><p><a>Set the password</a> given <a lt='URLUtils URL'>url</a>
 and the given value.

 <li><p>Run the <a>pre-update steps</a>.
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>host</code></dfn> attribute's getter must run
these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, return the
 empty string.

 <li><p>If <a lt='URL port'>port</a> is the empty string,
 return <a lt='URL host'>host</a>,
 <a lt='host serializer'>serialized</a>.

 <li><p>Return <a lt='URL host'>host</a>,
 <a lt='host serializer'>serialized</a>,
 "<code>:</code>", and <a lt='URL port'>port</a>
 concatenated.
</ol>

<p>The <code><a attribute for=URLUtils>host</a></code> attribute's setter must run these
steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, or its
 <a>relative flag</a> is unset, terminate these steps.

 <li><p><a lt='basic URL parser'>Basic URL parse</a> the given value with
 <a lt='URLUtils URL'>url</a> as <var>url</var> and
 <a>host state</a> as <var>state override</var>.

 <li><p>Run the <a>pre-update steps</a>.
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>hostname</code></dfn> attribute's getter
must run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, return the
 empty string.

 <li><p>Return <a lt='URL host'>host</a>,
 <a lt='host serializer'>serialized</a>.
</ol>

<p>The <code><a attribute for=URLUtils>hostname</a></code> attribute's setter must
run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, or its
 <a>relative flag</a> is unset, terminate these steps.

 <li><p><a lt='basic URL parser'>Basic URL parse</a> the given value with
 <a lt='URLUtils URL'>url</a> as <var>url</var> and
 <a>hostname state</a> as <var>state override</var>.

 <li><p>Run the <a>pre-update steps</a>.
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>port</code></dfn> attribute's getter must run
these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, return the
 empty string.

 <li><p>Return <a lt='URL port'>port</a>.
</ol>

<p>The <code><a attribute for=URLUtils>port</a></code> attribute's setter must run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, its
 <a>relative flag</a> is unset, or its
 <a lt='URL scheme'>scheme</a> is "<code>file</code>",
 terminate these steps.

 <li><p>Otherwise, <a lt='basic URL parser'>Basic URL parse</a>
 the given value with <a lt='URLUtils URL'>url</a> as <var>url</var> and
 <a>port state</a> as <var>state override</var>.

 <li><p>Run the <a>pre-update steps</a>.
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>pathname</code></dfn> attribute's getter
must run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, return the
 empty string.

 <li><p>If the <a>relative flag</a> is unset, return
 <a lt='URL scheme data'>scheme data</a>.

 <li><p>Return "<code>/</code>" concatenated with the strings in
 <a lt='URL path'>path</a> (including empty strings),
 separated from each other by "<code>/</code>".
</ol>

<p>The <code><a attribute for=URLUtils>pathname</a></code> attribute's setter must
run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, or its
 <a>relative flag</a> is unset, terminate these steps.

 <li><p>Empty <a lt='URL path'>path</a>.

 <li><p><a lt='basic URL parser'>Basic URL parse</a> the given value with
 <a lt='URLUtils URL'>url</a> as <var>url</var> and
 <a>relative path start state</a> as <var>state override</var>.

 <li><p>Run the <a>pre-update steps</a>.
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>search</code></dfn> attribute's getter must
run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, or its
 <a lt='URL query'>query</a> is either null or
 the empty string, return the empty string.

 <li><p>Return "<code>?</code>" concatenated with
 <a lt='URL query'>query</a>.
</ol>

<p>The <code><a attribute for=URLUtils>search</a></code> attribute's setter must run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, terminate these steps.

 <li><p>If the given value is the empty string, set
 <a lt='URL query'>query</a> to null, empty
 <a lt='URLUtils query object'>query object</a>'s
 <a lt='URLSearchParams list'>list</a>, run its
 <a lt='URLSearchParams update'>update steps</a>, and terminate these
 steps.

 <li><p>Let <var>input</var> be the given value with a single leading
 "<code>?</code>" removed, if any.

 <li><p>Set <a lt='URL query'>query</a> to the empty string.

 <li><p><a lt='basic URL parser'>Basic URL parse</a> <var>input</var>
 with <a lt='URLUtils URL'>url</a> as <var>url</var>,
 <a>query state</a> as <var>state override</var>, and the
 associated <a lt='URLUtils query encoding'>query encoding</a> as
 <var>encoding override</var>.

 <li><p>Set <a lt='URLUtils query object'>query object</a>'s
 <a lt='URLSearchParams list'>list</a> to the result of
 <a lt='urlencoded string parser'>parsing</a> <var lt="">input</var>.

 <li><p>Run <a lt='URLUtils query object'>query object</a>'s
 <a lt='URLSearchParams update'>update steps</a>.
</ol>

<p class="note no-backref">The <a lt='URLSearchParams update'>update steps</a> of
<a lt='URLUtils query object'>query object</a> are run to ensure all
<a lt='URLSearchParams URL object'>url objects</a> remain synchronized.

<p>The <dfn attribute dfn-for=URLUtils><code>searchParams</code></dfn> attribute's getter
must return the <a lt='URLUtils query object'>query object</a>.

<p>The <code><a attribute for=URLUtils>searchParams</a></code> attribute's setter must run
these steps:

<ol>
 <li><p>Let <var>object</var> be the given value.

 <li><p>Remove the <a>context object</a> from
 <a lt='URLUtils query object'>query object</a>'s list of
 <a lt='URLSearchParams URL object'>url objects</a>.

 <li><p>Append the <a>context object</a> to
 <var>object</var>'s list of
 <a lt='URLSearchParams URL object'>url objects</a>.

 <li><p>Set <a lt='URLUtils query object'>query object</a> to
 <var>object</var>.

 <li><p>Set <a lt='URL query'>query</a> to the
 <a lt='urlencoded serializer'>serialization</a> of the
 <a lt='URLUtils query object'>query object</a>'s
 <a lt='URLSearchParams list'>list</a>.

 <li><p>Run the <a>pre-update steps</a>.
</ol>

<p>The <dfn attribute dfn-for=URLUtils><code>hash</code></dfn> attribute's getter must run
these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, or its
 <a lt='URL fragment'>fragment</a> is either null or
 the empty string, return the empty string.

 <li><p>Return "<code>#</code>" concatenated with
 <a lt='URL fragment'>fragment</a>.
</ol>

<p>The <code><a attribute for=URLUtils>hash</a></code> attribute's setter must run these steps:

<ol>
 <li><p>If <a lt='URLUtils URL'>url</a> is null, or its
 <a lt='URL scheme'>scheme</a> is
 "<code>javascript</code>", terminate these steps.

 <li><p>If the given value is the empty string, set
 <a lt='URL fragment'>fragment</a> to null, run the
 <a>pre-update steps</a>, and terminate these steps.

 <li><p>Let <var>input</var> be the given value with a single leading
 "<code>#</code>" removed, if any.

 <li><p>Set <a lt='URL fragment'>fragment</a> to
 the empty string.

 <li><p><a lt='basic URL parser'>Basic URL parse</a> <var>input</var>
 with <a lt='URLUtils URL'>url</a> as <var>url</var> and
 <a>fragment state</a> as <var>state override</var>.

 <li><p>Run the <a>pre-update steps</a>.
</ol>


<h3 id=interface-urlsearchparams>Interface <code><a interface>URLSearchParams</a></code></h3>

<pre class=idl>[Constructor(optional (USVString or URLSearchParams) init = ""),
 Exposed=(Window,Worker)]
interface URLSearchParams {
  void append(USVString name, USVString value);
  void delete(USVString name);
  USVString? get(USVString name);
  sequence&lt;USVString> getAll(USVString name);
  boolean has(USVString name);
  void set(USVString name, USVString value);
  iterable&lt;USVString, USVString>;
  stringifier;
};</pre>

<p>A {{URLSearchParams}} object has an associated
<dfn id=concept-urlsearchparams-list lt='URLSearchParams list'>list</dfn> of name-value pairs, which is initially
empty.

<p>A {{URLSearchParams}} object has an associated list of zero or more
<dfn id=concept-urlsearchparams-url-object lt='URLSearchParams URL object'>url objects</dfn>, which is initially empty.

<p class=note>{{URLSearchParams}} objects always use <a>utf-8</a> as <a>encoding</a>,
despite the existence of concepts such as
<a lt='URLUtils query encoding'>query encoding</a>. This is to
encourage developers to migrate towards
<a>utf-8</a>, which they really ought to
have done a long time ago now.

<p>To create a
<dfn id=concept-urlsearchparams-new lt='URLSearchParams new'>new <code>URLSearchParams</code> object</dfn>,
optionally using <var>init</var>, run these steps:

<ol>
 <li><p>Let <var>query</var> be a new {{URLSearchParams}} object.

 <li><p>If <var>init</var> is a string,
 set <var>query</var>'s <a lt='URLSearchParams list'>list</a> to the
 result of <a lt='urlencoded string parser'>parsing</a>
 <var>init</var>.

 <li><p>If <var>init</var> is a {{URLSearchParams}} object, set
 <var>query</var>'s <a lt='URLSearchParams list'>list</a> to a copy
 of <var>init</var>'s <a lt='URLSearchParams list'>list</a>.

 <li><p>Return <var>query</var>.
</ol>

<p>A {{URLSearchParams}} object's
<dfn id=concept-urlsearchparams-update lt='URLSearchParams update'>update steps</dfn> are to run these steps for
each associated  <a lt='URLSearchParams URL object'>url object</a>
<var>urlObject</var>, in order:

<ol>
 <li><p>Set <var>urlObject</var>'s <a lt='URLUtils URL'>url</a>'s
 <a lt='URL query'>query</a> to the
 <a lt='urlencoded serializer'>serialization</a> of
 {{URLSearchParams}} object's
 <a lt='URLSearchParams list'>list</a>.

 <li><p>Run <var>urlObject</var>'s <a>pre-update steps</a>.
</ol>

<p>The
<dfn constructor dfn-for=URLSearchParams><code>URLSearchParams(<var>init</var>)</code></dfn>
constructor, when invoked, must return a
<a lt='URLSearchParams new'>new <code>URLSearchParams</code> object</a>
using <var>init</var> if given.

<p>The
<dfn method dfn-for=URLSearchParams><code>append(<var>name</var>, <var>value</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Append a new name-value pair whose name is <var>name</var> and
 value is <var>value</var>, to <a lt='URLSearchParams list'>list</a>.

 <li><p>Run the <a lt='URLSearchParams update'>update steps</a>.
</ol>

<p>The
<dfn method dfn-for=URLSearchParams><code>delete(<var>name</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Remove all name-value pairs whose name is <var>name</var> from
 <a lt='URLSearchParams list'>list</a>.

 <li><p>Run the <a lt='URLSearchParams update'>update steps</a>.
</ol>

<p>The
<dfn method dfn-for=URLSearchParams><code>get(<var>name</var>)</code></dfn>
method, when invoked, must return the value of the first name-value pair whose name is
<var>name</var> in <a lt='URLSearchParams list'>list</a>, and null if
there is no such pair.

<p>The
<dfn method dfn-for=URLSearchParams><code>getAll(<var>name</var>)</code></dfn>
method, when invoked, must return the values of all name-value pairs whose name is
<var>name</var>, in <a lt='URLSearchParams list'>list</a>,
in list order, and the empty sequence otherwise.

<p>The
<dfn method dfn-for=URLSearchParams><code>set(<var>name</var>, <var>value</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>If there are any name-value pairs whose name is <var>name</var>, in
 <a lt='URLSearchParams list'>list</a>, set the value of the first such
 name-value pair to <var>value</var> and remove the others.

 <li><p>Otherwise, append a new name-value pair whose name is <var>name</var> and
 value is <var>value</var>, to <a lt='URLSearchParams list'>list</a>.

 <li><p>Run the <a lt='URLSearchParams update'>update steps</a>.
</ol>

<p>The
<dfn method dfn-for=URLSearchParams><code>has(<var>name</var>)</code></dfn>
method, when invoked, must return true if there is a name-value pair whose name is
<var>name</var> in <a lt='URLSearchParams list'>list</a>, and false
otherwise.

<p>The <a>value pairs to iterate over</a> are the
<a lt='URLSearchParams list'>list</a> name-value pairs with the key being
the name and the value the value.

<p>The <dfn dfn dfn-for=URLSearchParams>stringification behavior</dfn> must return the
<a lt='urlencoded serializer'>serialization</a> of the
{{URLSearchParams}} object's
<a lt='URLSearchParams list'>list</a>.


<h3 id=url-apis-elsewhere>URL APIs elsewhere</h3>

<p>A standard that exposes <a lt='URL'>URLs</a>, should expose the
<a>URL</a> as a string (by <a lt='URL serializer'>serializing</a> an internal
<a>URL</a>). A standard should not expose a <a>URL</a> using a
{{URL}} object. {{URL}} objects are
meant for <a>URL</a> manipulation. In IDL the USVString type should be used.

<p class=note>The higher-level notion here is that values are to be exposed as immutable
data structures.

<p>If a standard decides to use a variant of the name "URL" for a feature it defines, it
should name such a feature "url" (i.e. lowercase and with an "l" at the end). Names such
as "URL", "URI", and "IRI" should not be used. However, if the name is a compound, "URL"
(i.e. uppercase) is preferred, e.g. "newURL" and "oldURL".

<p class=note>The {{EventSource}} and
{{HashChangeEvent}} interfaces in HTML are examples of
proper naming. [[!HTML]]



<h2 id=acknowledgments class=no-num>Acknowledgments</h2>

<p>There have been a lot of people that have helped make
<a lt='URL' class=no-backref>URLs</a> more interoperable over the years and
thereby furthered the goals of this standard. Likewise many people have helped making this
standard what it is today.

<p>With that, many thanks to
Adam Barth,
Albert Wiersch,
Alexandre Morgaut,
Arkadiusz Michalski,
Behnam Esfahbod,
Bobby Holley,
Boris Zbarsky,
Brandon Ross,
Dan Appelquist,
Daniel Bratell,
David Håsäther,
David Sheets,
David Singer,
Erik Arvidsson,
Gavin Carothers,
Geoff Richards,
Glenn Maynard,
Henri Sivonen,
Ian Hickson,
James Graham,
James Manger,
James Ross,
Joshua Bell,
Jxck,
Kevin Grandon,
Larry Masinter,
Mark Davis,
Marcos Cáceres,
Martin Dürst,
Mathias Bynens,
Michael Peick,
Michael™ Smith,
Michel Suignard,
Peter Occil,
Rodney Rehm,
Roy Fielding,
Santiago M. Mola,
Simon Pieters,
Simon Sapin,
Tab Atkins,
Tantek Çelik,
Tim Berners-Lee,
Vyacheslav Matva, and
成瀬ゆい (Yui Naruse)
for being awesome!

<p>This standard is written by
<a lang=nl href=https://annevankesteren.nl/>Anne van Kesteren</a>
(<a href=https://www.mozilla.org/>Mozilla</a>,
<a href=mailto:annevk@annevk.nl>annevk@annevk.nl</a>)
and
<a lang=en-US href=http://intertwingly.net/>Sam Ruby</a>
(<a href=//www.ibm.com/>IBM</a>,
<a href=mailto:rubys@intertwingly.net>rubys@intertwingly.net</a>).

<p>Per <a rel="license" href="//creativecommons.org/publicdomain/zero/1.0/">CC0</a>, to
the extent possible under law, the editors have waived all copyright and related or
neighboring rights to this work.

<pre class="biblio">
{
    "IDNA": {
        "authors": [
            "Mark Davis",
            "Michel Suignard"
        ],
        "href": "http://www.unicode.org/reports/tr46/",
        "title": "Unicode IDNA Compatibility Processing",
        "publisher": "Unicode Consortium"
    },
    "DOM": {
        "authors": [
            "Anne van Kesteren"
        ],
        "href": "https://dom.spec.whatwg.org/",
        "title": "DOM",
        "publisher": "WHATWG"
    },
    "ENCODING": {
        "authors": [
            "Anne van Kesteren"
        ],
        "href": "https://encoding.spec.whatwg.org/",
        "title": "Encoding",
        "publisher": "WHATWG"
    },
    "FILEAPI": {
        "authors": [
            "Arun Ranganathan",
            "Jonas Sicking"
        ],
        "href": "http://dev.w3.org/2006/webapi/FileAPI/",
        "title": "File API",
        "publisher": "W3C"
    },
    "WEBIDL": {
        "authors": [
            "Boris Zbarsky",
            "Cameron McCormack"
        ],
        "href": "https://heycam.github.io/webidl/",
        "title": "Web IDL",
        "publisher": "W3C"
    }
}
</pre>

<pre class="anchors">
urlPrefix: http://dev.w3.org/2006/webapi/FileAPI/; type: dfn
  text: blob
  text: blob url store; url: #BlobURLStore
urlPrefix: https://dom.spec.whatwg.org/; type: dfn
  text: concept-attribute-value; url: concept-attribute-value
  text: concept-document; url: concept-document
  text: context object
  text: dom-node-baseuri; url: dom-node-baseuri
urlPrefix: https://encoding.spec.whatwg.org/; type: dfn
  text: ascii whitespace
  text: concept-encoding-get; url: concept-encoding-get
  text: decoder
  text: encode
  text: encoding
  text: error
  text: utf-8; url: utf-8
  text: utf-8 decode without bom; url: utf-8-decode-without-bom
  text: utf-8 encode; url: utf-8-encode
  text: utf-8 decoder; url: utf-8-decoder
urlPrefix: https://html.spec.whatwg.org/multipage/
  urlPrefix: comms.html; type: interface;
    text: EventSource
    text: HashChangeEvent
  urlPrefix: browsers.html; type: dfn;
    text: origin
    text: unicode serialisation of an origin
  urlPrefix: infrastructure.html; type: dfn;
    text: structured clone
urlPrefix: https://heycam.github.io/webidl/#dfn-; type: dfn;
  text: throw
  text: value pairs to iterate over
url: http://www.unicode.org/reports/tr46/#ToASCII; type: dfn; text: toascii
url: http://www.unicode.org/reports/tr46/#ToUnicode; type: dfn; text: tounicode
</pre>

<script id=head src=https://resources.whatwg.org/dfn.js></script>
